<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/posts/ab21860c/"/>
    <url>/posts/ab21860c/</url>
    
    <content type="html"><![CDATA[<h4 id="hexo-d提示无法连接到github-援引自CSDN和StackOverFlow"><a href="#hexo-d提示无法连接到github-援引自CSDN和StackOverFlow" class="headerlink" title="hexo d提示无法连接到github(援引自CSDN和StackOverFlow)"></a>hexo d提示无法连接到github(援引自<a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">CSDN</a>和<a href="https://stackoverflow.com/questions/15589682/how-to-fix-ssh-connect-to-host-github-com-port-22-connection-timed-out-for-g">StackOverFlow</a>)</h4><p>1.在git bash进入~&#x2F;.ssh下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.ssh<br></code></pre></td></tr></table></figure><p>2.创建一个config文件(这里我用的vim编辑器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim config<br></code></pre></td></tr></table></figure><p>3.编辑文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host github.com<br>User git<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port 443<br><br>Host gitlab.com<br>Hostname altssh.gitlab.com<br>User git<br>Port 443<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p>4.保存退出</p><p>5.检查是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>这里要根据它的提示操作，有个地方要输入yes</p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/posts/ab21860c/"/>
    <url>/posts/ab21860c/</url>
    
    <content type="html"><![CDATA[<h2 id="最简洁的常用流程"><a href="#最简洁的常用流程" class="headerlink" title="最简洁的常用流程"></a>最简洁的常用流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先把markdown文件放到post文件夹中</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清除之前生成的静态文件</span><br>hexo clean<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成静态文件，hexo generate 的简写</span><br>hexo g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地启动，hexo server 的简写,用于查看效果，可以跳过</span><br>hexo s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">部署到 Git 仓库，hexo deploy 的简写</span><br>hexo d<br></code></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init [folder]</span><br></code></pre></td></tr></table></figure><p>新建一个网站。 如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.io/zh/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。 npm 默认随 <a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new [layout] &lt;title&gt;</span><br></code></pre></td></tr></table></figure><p>新建一篇文章。 如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。 使用布局 <code>draft</code> 来创建草稿。 如果标题包含空格的话，请使用引号括起来。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>文章的路径。 自定义文章的路径。</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在的话，替换当前的文章。</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章别名。 自定义文章的 URL。</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。 对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。 你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page --path about/me &quot;About me&quot;<br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！ title 是必须指定的！ 例如，这不会产生您可能期望的行为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page --path about/me<br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。 这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>在生成完成后部署。</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成</td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>要同时生成的文件的最大数量。 默认无限制</td></tr></tbody></table><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo publish [layout] &lt;filename&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo server<br></code></pre></td></tr></table></figure><p>启动服务器。 默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启用日志。 Override logger format.</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo deploy</span><br></code></pre></td></tr></table></figure><p>部署你的网站。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>在部署前生成</td></tr></tbody></table><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo render &lt;file1&gt; [file2] ...</span><br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output</code></td><td>输出目标地址</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo migrate &lt;<span class="hljs-built_in">type</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean</span><br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo list &lt;<span class="hljs-built_in">type</span>&gt;</span><br></code></pre></td></tr></table></figure><p>列出所有路由。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo version</span><br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo config [key] [value]</span><br></code></pre></td></tr></table></figure><p>列出网站的配置（<code>_config.yml</code>）。 如果指定了 <code>key</code>，则只展示配置中对应 <code>key</code> 的值；如果同时指定了 <code>key</code> 和 <code>value</code>，则将配置中对应的 <code>key</code> 的值修改为 <code>value</code>。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --safe</span><br></code></pre></td></tr></table></figure><p>在安全模式下，不会加载插件和脚本。 当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --debug</span><br></code></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。 当您使用 Hexo 时遇到问题，可以尝试用调试模式重新执行一次。 如果您发现错误，请<a href="https://github.com/hexojs/hexo/issues/new?assignees=&labels=&projects=&template=bug_report.yml">在 GitHub 上提出 issue</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --silent</span><br></code></pre></td></tr></table></figure><p>静默输出到终端.</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --config custom.yml</span><br></code></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。 还接受一个以逗号分隔的 JSON 或 YAML 配置文件列表（无空格），该列表将把这些文件合并为一个 <code>_multiconfig.yml</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --config custom.yml,custom2.json</span><br></code></pre></td></tr></table></figure><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --draft</span><br></code></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo --cwd /path/to/cwd</span><br></code></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/posts/f3b98ae9/"/>
    <url>/posts/f3b98ae9/</url>
    
    <content type="html"><![CDATA[<ul><li>前端界面初始化后出现格式乱码，挤在页面中央等情况：<ul><li>初始化的css文件是否已经完全删除？</li></ul></li></ul><hr><p>- </p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot注解</title>
    <link href="/posts/2f294b8e/"/>
    <url>/posts/2f294b8e/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a><code>@TableLogic</code></h4><ul><li><strong>MyBatis-Plus 框架</strong> 中提供的一个注解，用于实现数据库的 ​<strong>逻辑删除</strong> 功能。它的核心作用是将数据标记为“已删除”状态（而不是物理删除数据），从而保留数据完整性和可追溯性。</li><li><strong><code>@TableLogic</code> 的用途</strong>: 通过该注解，​<strong>MyBatis-Plus 会自动实现以下逻辑</strong>：<ol><li>​<strong>删除操作</strong>：将 <code>DELETE</code> 语句转换为 <code>UPDATE</code>，修改标记字段的值。</li><li>​<strong>查询操作</strong>：自动在查询条件中添加 <code>WHERE is_deleted = 0</code>，排除已删除数据。</li><li>​<strong>数据恢复</strong>：通过更新标记字段的值，恢复被逻辑删除的数据。</li></ol></li><li><em><strong>注意！！！</strong></em>：必须增加<code>@TableLogic</code>注解，MyBatis才能识别该变量用于判断<em>逻辑删除</em><br><strong>（1）基本用法</strong><br>在实体类中标记逻辑删除字段：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer isDeleted; <span class="hljs-comment">// 逻辑删除标记字段</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>​（2）自定义删除标记值</strong></p><ul><li><p>默认值：</p><ul><li>​<strong>未删除</strong>：<code>0</code></li><li>​<strong>已删除</strong>：<code>1</code></li></ul></li><li><p>通过注解属性自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)</span>  <span class="hljs-comment">// 未删除=0，已删除=1</span><br><span class="hljs-keyword">private</span> Integer status;<br></code></pre></td></tr></table></figure></li><li><p>支持其他类型（如字符串）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic(value = &quot;NO&quot;, delval = &quot;YES&quot;)</span>  <span class="hljs-comment">// 未删除=&quot;NO&quot;，已删除=&quot;YES&quot;</span><br><span class="hljs-keyword">private</span> String isDeleted;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目开发杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发杂记</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发工具类（减少造轮子）</title>
    <link href="/posts/56877132/"/>
    <url>/posts/56877132/</url>
    
    <content type="html"><![CDATA[<h2 id="Java自带"><a href="#Java自带" class="headerlink" title="Java自带"></a>Java自带</h2><h3 id="CollectionsUtils"><a href="#CollectionsUtils" class="headerlink" title="CollectionsUtils"></a>CollectionsUtils</h3><ul><li>用于简化集合（<code>Collection</code>、<code>List</code>、<code>Map</code> 等）的操作。它封装了多种集合操作的静态方法，可以安全处理空集合、实现集合的过滤、转换、合并等逻辑，避免开发者重复编写底层代码。</li></ul><h4 id="核心功能与用法"><a href="#核心功能与用法" class="headerlink" title="核心功能与用法"></a>核心功能与用法</h4><ul><li><p><strong>​（1）判断集合是否为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections4.CollectionUtils;<br><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> CollectionUtils.isEmpty(list); <span class="hljs-comment">// true</span><br><br>List&lt;String&gt; list2 = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isNotEmpty</span> <span class="hljs-operator">=</span> CollectionUtils.isNotEmpty(list2); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>​<strong>​（2）集合的交集、并集、差集</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; listA = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>List&lt;String&gt; listB = Arrays.asList(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br><br><span class="hljs-comment">// 交集：两个集合都包含的元素</span><br>Collection&lt;String&gt; intersection = <br>    CollectionUtils.intersection(listA, listB); <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br><br><span class="hljs-comment">// 并集：合并两个集合的所有元素（去重）</span><br>Collection&lt;String&gt; union = <br>    CollectionUtils.union(listA, listB); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><br><span class="hljs-comment">// 差集：A 中有但 B 中没有的元素</span><br>Collection&lt;String&gt; subtract = <br>    CollectionUtils.subtract(listA, listB); <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p>​**（3）过滤集合元素 **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 过滤出偶数</span><br>CollectionUtils.filter(numbers, n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <br><span class="hljs-comment">// numbers 变为 [2, 4]（直接修改原集合！）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>（4）集合转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br><br><span class="hljs-comment">// 将字符串转换为整数</span><br>Collection&lt;Integer&gt; integers = <br>    CollectionUtils.collect(strings, s -&gt; Integer.parseInt(s)); <br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>​（5）安全处理空集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 避免空指针异常</span><br><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;集合为空&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="回忆：Java-中的集合框架（Java-Collections-Framework）​"><a href="#回忆：Java-中的集合框架（Java-Collections-Framework）​" class="headerlink" title="回忆：Java 中的集合框架（Java Collections Framework）​"></a>回忆：Java 中的集合框架（Java Collections Framework）​</h4><ul><li>​<strong>根接口</strong>：<code>Collection&lt;E&gt;</code>，定义了集合的基本操作。</li><li>​<strong>核心子接口</strong>：</li></ul><table><thead><tr><th>接口</th><th>说明</th><th>常见实现类</th></tr></thead><tbody><tr><td>​<strong>List</strong></td><td>有序集合，允许重复元素</td><td><code>ArrayList</code>, <code>LinkedList</code></td></tr><tr><td>​<strong>Set</strong></td><td>无序集合，元素唯一</td><td><code>HashSet</code>, <code>TreeSet</code></td></tr><tr><td>​<strong>Queue</strong></td><td>队列，先进先出（FIFO）或优先队列</td><td><code>LinkedList</code>, <code>PriorityQueue</code></td></tr><tr><td>​<strong>Deque</strong></td><td>双端队列，支持两端插入和删除</td><td><code>ArrayDeque</code></td></tr></tbody></table><ul><li>​<strong>示例代码</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// List 示例：允许重复，按插入顺序存储</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Apple&quot;</span>);  <span class="hljs-comment">// 允许重复</span><br><br><span class="hljs-comment">// Set 示例：元素唯一，无序</span><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set.add(<span class="hljs-number">1</span>);<br>set.add(<span class="hljs-number">2</span>);<br>set.add(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 重复元素会被忽略</span><br><br><span class="hljs-comment">// 遍历集合</span><br><span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>System.out.println(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><ul><li><strong>MyBatis-Plus（MP）​</strong> 框架中用于动态构建 SQL 查询条件的核心工具类。它通过链式调用方法（如 <code>eq()</code>, <code>like()</code>, <code>between()</code> 等）生成 <code>WHERE</code> 子句，替代手写 SQL，提升开发效率和代码可读性。</li></ul><h4 id="使用步骤（Spring-Boot-MyBatis-Plus）"><a href="#使用步骤（Spring-Boot-MyBatis-Plus）" class="headerlink" title="使用步骤（Spring Boot + MyBatis-Plus）"></a>使用步骤（Spring Boot + MyBatis-Plus）</h4><ul><li><p>​<strong>步骤 1：添加 MyBatis-Plus 依赖</strong>，在 <code>pom.xml</code> 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新版本 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>步骤 2：定义实体类</strong><br>假设有一个 <code>User</code> 表，对应实体类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;user&quot;)</span> <span class="hljs-comment">// 表名映射（若表名与类名一致可省略）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span> <span class="hljs-comment">// 主键自增</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>​<strong>步骤 3：创建 Mapper 接口</strong><br>继承 <code>BaseMapper</code>，获得 MyBatis-Plus 的 CRUD 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>    <span class="hljs-comment">// 可自定义 SQL 方法（此处不写，直接使用 BaseMapper 的方法）</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>​<strong>步骤 4：在 Service 或 Controller 中使用 QueryWrapper</strong><br>通过 <code>QueryWrapper</code> 构建查询条件，并调用 <code>selectList()</code>, <code>selectOne()</code>, <code>update()</code>, <code>delete()</code> 等方法。</p></li></ul><h4 id="​核心方法及示例"><a href="#​核心方法及示例" class="headerlink" title="​核心方法及示例"></a>​核心方法及示例</h4><p><strong>​（1）基础查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserMapper userMapper;<br><br><span class="hljs-comment">// 查询所有 age &gt; 18 的用户</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersByAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.gt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// age &gt; 18</span><br>    <span class="hljs-keyword">return</span> userMapper.selectList(queryWrapper);<br>&#125;<br><br><span class="hljs-comment">// 查询 username = &quot;张三&quot; 的用户</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserByName</span><span class="hljs-params">(String username)</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(<span class="hljs-string">&quot;username&quot;</span>, username);<br>    <span class="hljs-keyword">return</span> userMapper.selectOne(queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>​（2）复杂条件组合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询 age 在 20-30 之间，且 email 包含 &quot;example.com&quot; 的用户</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersByCondition</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.between(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br>               .like(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;example.com&quot;</span>);<br>    <span class="hljs-keyword">return</span> userMapper.selectList(queryWrapper);<br>&#125;<br><br><span class="hljs-comment">// 查询 username 以 &quot;张&quot; 开头，或 age &lt; 18 的用户</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersByOr</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.likeRight(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;张&quot;</span>)<br>               .or()<br>               .lt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">return</span> userMapper.selectList(queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p>​<strong>​（3）排序和分页</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按 age 降序排序</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersOrderByAge</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.orderByDesc(<span class="hljs-string">&quot;age&quot;</span>);<br>    <span class="hljs-keyword">return</span> userMapper.selectList(queryWrapper);<br>&#125;<br><br><span class="hljs-comment">// 分页查询（需配置 MyBatis-Plus 分页插件）</span><br><span class="hljs-keyword">public</span> Page&lt;User&gt; <span class="hljs-title function_">getUsersByPage</span><span class="hljs-params">(Integer pageNum, Integer pageSize)</span> &#123;<br>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNum, pageSize);<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-keyword">return</span> userMapper.selectPage(page, queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p> ​<strong>​（4）更新和删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 age &gt; 30 的用户 email 设为 null</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUsersEmail</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setEmail(<span class="hljs-literal">null</span>);<br>    <br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.gt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">30</span>);<br>    userMapper.update(user, queryWrapper);<br>&#125;<br><br><span class="hljs-comment">// 删除 username 包含 &quot;test&quot; 的用户</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUsersByName</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br>    userMapper.delete(queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="​高级用法"><a href="#​高级用法" class="headerlink" title="​高级用法"></a>​<strong>高级用法</strong></h4><p><strong>​（1）LambdaQueryWrapper（推荐）​</strong><br>避免字段名硬编码，使用实体类属性的 getter 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserByLambda</span><span class="hljs-params">(String username)</span> &#123;<br>    LambdaQueryWrapper&lt;User&gt; lambdaQuery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    lambdaQuery.eq(User::getUsername, username);<br>    <span class="hljs-keyword">return</span> userMapper.selectOne(lambdaQuery);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）嵌套条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询 (age &gt; 18 AND email 不为空) OR username = &quot;admin&quot;</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersWithNested</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.and(wrapper -&gt; wrapper.gt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>).isNotNull(<span class="hljs-string">&quot;email&quot;</span>))<br>               .or()<br>               .eq(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-keyword">return</span> userMapper.selectList(queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p> ​<strong>​（3）联表查询</strong><br>需配合自定义 SQL 和 <code>@TableField</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 实体类中添加关联字段（假设需要关联部门表）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-meta">@TableField(exist = false)</span> <span class="hljs-comment">// 非数据库字段</span><br>    <span class="hljs-keyword">private</span> String deptName;<br>&#125;<br><br><span class="hljs-comment">// 2. Mapper 接口中定义方法</span><br><span class="hljs-meta">@Select(&quot;SELECT u.*, d.name AS dept_name FROM user u LEFT JOIN dept d ON u.dept_id = d.id $&#123;ew.customSqlSegment&#125;&quot;)</span><br>List&lt;User&gt; <span class="hljs-title function_">selectUserWithDept</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;<br><br><span class="hljs-comment">// 3. 使用 QueryWrapper 添加条件</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUsersWithDept</span><span class="hljs-params">(String deptName)</span> &#123;<br>    QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(<span class="hljs-string">&quot;d.name&quot;</span>, deptName);<br>    <span class="hljs-keyword">return</span> userMapper.selectUserWithDept(queryWrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="​总结"><a href="#​总结" class="headerlink" title="​总结"></a>​<strong>总结</strong></h4><table><thead><tr><th>​<strong>场景</strong></th><th>​<strong>方法示例</strong></th></tr></thead><tbody><tr><td>等值查询</td><td><code>.eq(&quot;字段名&quot;, 值)</code></td></tr><tr><td>模糊查询</td><td><code>.like(&quot;字段名&quot;, 值)</code></td></tr><tr><td>范围查询</td><td><code>.between(&quot;字段名&quot;, 最小值, 最大值)</code></td></tr><tr><td>排序</td><td><code>.orderByAsc(&quot;字段名&quot;)</code></td></tr><tr><td>分页</td><td><code>Page&lt;T&gt; + selectPage()</code></td></tr><tr><td>复杂条件组合</td><td><code>.and()</code>, <code>.or()</code></td></tr><tr><td>避免字段名硬编码</td><td>​<strong>使用 <code>LambdaQueryWrapper</code></strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目开发杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发杂记</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook</title>
    <link href="/posts/2641cf45/"/>
    <url>/posts/2641cf45/</url>
    
    <content type="html"><![CDATA[<h4 id="Jupyter-Lab指定Conda环境作为Kernel"><a href="#Jupyter-Lab指定Conda环境作为Kernel" class="headerlink" title="Jupyter Lab指定Conda环境作为Kernel"></a>Jupyter Lab指定Conda环境作为Kernel</h4><ul><li><em><strong>问题</strong></em><br>本地安装好Anaconda后，可以在Anaconda Prompt里执行如下命令启动Jupyter Lab</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jupyter lab<br></code></pre></td></tr></table></figure><p>我们在创建notebook的时候，可以选择kernel。</p><p>初始安装后，只有一个默认的kernel: Python 3，那我们怎么可以添加新的kernel呢？</p><p>方法是基于conda创建新的环境，然后把新的环境安装到Jupyter Lab的Kernel里，界面上就可以显示新的Kernel了。</p><ul><li><p><em><strong>操作步骤</strong></em></p></li><li><p>第一步，创建你需要的conda环境，假设名字为quant-dev。</p></li><li><p>第二步，激活你的环境quant-dev。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda activate quant-dev<br></code></pre></td></tr></table></figure></li><li><p>在这个conda环境里安装你需要的各种依赖包。<br>  使用conda install或者pip install都可以，都会把package安装在当前所处的quant-dev环境。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install package_xxx<br>pip install package_xxx<br></code></pre></td></tr></table></figure></li><li><p>第三步，安装ipykernel。如果你的环境已经有了ipykernel那就可以跳过。使用conda install或者pip install安装都可以。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda install ipykernel<br>pip install ipykernel<br></code></pre></td></tr></table></figure></li><li><p>第四步，把conda环境写入jupyterlab的kernel中，用于Jupyter Lab界面显示。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m ipykernel install --name quant-dev --display-name quant-dev<br></code></pre></td></tr></table></figure><ul><li><p>–name后面的参数是kernel的名字，执行<code>jupyter kernelspec list</code>会显示这里的名字。</p></li><li><p>–display-name后面的参数是Jupyter Lab界面显示的Kernel名字。</p></li><li><p>如果在上述命令增加–user则只给当前用户安装，而不是给系统里所有用户都安装。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m ipykernel install --user --name quant-dev --display-name quant-dev<br></code></pre></td></tr></table></figure></li></ul></li><li><p>第五步，刷新Jupyter Lab页面，就可以展示新加的Kernel了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>jupyter_notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA</title>
    <link href="/posts/3c1e27f1/"/>
    <url>/posts/3c1e27f1/</url>
    
    <content type="html"><![CDATA[<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul><li>MyBatisX : 目前使用体验最好的SQL操作插件</li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>JetBrain全家桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/posts/518e617c/"/>
    <url>/posts/518e617c/</url>
    
    <content type="html"><![CDATA[<ul><li>超好用git 入门教程: <a href="https://cloud.tencent.com/developer/article/1504684">https://cloud.tencent.com/developer/article/1504684</a></li></ul><h4 id="JetBrain系列IDE的git配置（本地项目上传github）"><a href="#JetBrain系列IDE的git配置（本地项目上传github）" class="headerlink" title="JetBrain系列IDE的git配置（本地项目上传github）"></a>JetBrain系列IDE的git配置（本地项目上传github）</h4><ul><li>最重要的一点：部分网络环境（例如校园网）会限制http形式443端口的连接，所以无法进行push&#x2F;pull相关操作，需要<em>使用SSH连接！！！</em></li><li>如果直接拉取项目内容，git clone即可，但是本地git仓库用IDE连接也不是很方便，还是直接用git建立连接，而不是用IDE（IDEA的share on github选项似乎默认使用https，连接会出现类似如下报错）<ul><li><em>Cannot load information for github.com&#x2F;VVX94:Request response: Access tothis site has been restricted.</em></li></ul></li><li>法一：<ul><li>github新建空白repository，复制对应SSH备用</li><li>本地选定项目文件夹，右键git bash here</li><li>输入<code>git clone git@github.com:yourName/yourProjectName.git</code></li><li>直接克隆空项目到本地，然后把项目内容移到clone的文件夹内</li><li>输入如下指令<ul><li><code>git add *</code> （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）</li><li><code>git commit  -m  &quot;提交信息&quot;</code>  （注：“提交信息”里面换成你需要，如“first commit”）</li><li><code>git push -u origin master</code>   （注：此操作目的是把本地仓库push到github上面）</li></ul></li></ul></li><li>法二：本地先创造一个git仓库，然后增加远程<ul><li>在项目内通过命令git init把这个文件夹变成Git可管理的仓库</li><li>通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）</li><li>git commit把项目提交到本地仓库</li><li>在github创建一个空仓库</li><li>Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入</li><li><code>git remote add origin git@github.com:yourName/yourProjectName.git</code></li><li>关联之后通过<code>git push -u origin master</code>推送到github</li><li>由于新建的远程仓库是空的，所以要加上<code>-u</code>这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了： <code>$ git push origin master</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/posts/7b25d017/"/>
    <url>/posts/7b25d017/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/posts/9211474f/"/>
    <url>/posts/9211474f/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 树状显示文件目录</span><br>tree 目标目录<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook</title>
    <link href="/posts/2641cf45/"/>
    <url>/posts/2641cf45/</url>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook 有两种键盘输入模式。</p><ul><li>编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。</li><li>命令模式，键盘输入运行程序命令；这时的单元框线是灰色。</li></ul><h2 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h2><ul><li><em>Enter : 转入编辑模式</em></li><li><em>Shift-Enter : 运行本单元，选中下个单元</em></li><li><em>Ctrl-Enter : 运行本单元</em></li><li><em>Alt-Enter : 运行本单元，在其下插入新单元</em></li><li><em>Y : 单元转入代码状态</em></li><li><em>M :单元转入markdown状态</em></li><li><em>R : 单元转入raw状态</em></li><li>1 : 设定 1 级标题</li><li>2 : 设定 2 级标题</li><li>3 : 设定 3 级标题</li><li>4 : 设定 4 级标题</li><li>5 : 设定 5 级标题</li><li>6 : 设定 6 级标题</li><li>Up : 选中上方单元</li><li><em>K : 选中上方单元</em></li><li>Down : 选中下方单元</li><li><em>J : 选中下方单元</em></li><li>Shift-K : 扩大选中上方单元</li><li>Shift-J : 扩大选中下方单元</li><li><em>A : 在上方插入新单元</em></li><li><em>B : 在下方插入新单元</em></li><li><em>X : 剪切选中的单元</em></li><li><em>C : 复制选中的单元</em></li><li>Shift-V : 粘贴到上方单元</li><li>V : 粘贴到下方单元</li><li>Z : 恢复删除的最后一个单元</li><li><em>D,D : 删除选中的单元</em></li><li>Shift-M : 合并选中的单元</li><li>Ctrl-S : 文件存盘</li><li>S : 文件存盘</li><li>L : 转换行号</li><li>O : 转换输出</li><li>Shift-O : 转换输出滚动</li><li>Esc : 关闭页面</li><li>Q : 关闭页面</li><li>H : 显示快捷键帮助</li><li><em>I,I : 中断Notebook内核</em></li><li><em>0,0 : 重启Notebook内核</em></li><li>Shift : 忽略</li><li>Shift-Space : 向上滚动</li><li>Space : 向下滚动</li></ul><h2 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h2><ul><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li><em>Shift-Enter : 运行本单元，选中下一单元</em></li><li><em>Ctrl-Enter : 运行本单元</em></li><li><em>Alt-Enter : 运行本单元，在下面插入一单元</em></li><li>Ctrl-Shift– : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ul>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>jupyter_notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java</title>
    <link href="/posts/7f1ae6d2/"/>
    <url>/posts/7f1ae6d2/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="Arrays-copyofRange-arr-start-end"><a href="#Arrays-copyofRange-arr-start-end" class="headerlink" title="Arrays.copyofRange(arr,start,end);"></a><code>Arrays.copyofRange(arr,start,end);</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//create a new array by copying a specified range of elements from an existing array. It provides a way to copy a subset of elements between two indices by creating a new array of the same type</span><br><br><span class="hljs-comment">//左闭右开区间</span><br><span class="hljs-comment">//e.g.</span><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// Original array</span><br>        <span class="hljs-type">int</span>[] arr1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>,&#125;;<br>        <span class="hljs-comment">// Copy elements from index 1 to 3 (exclusive)</span><br>        <span class="hljs-type">int</span>[] arr2 = Arrays.copyOfRange(arr1, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        System.out.println(<span class="hljs-string">&quot;Copied Array: &quot;</span> + Arrays.toString(arr2));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//result: [20,30]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda</title>
    <link href="/posts/2980492/"/>
    <url>/posts/2980492/</url>
    
    <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="查询-conda-版本"><a href="#查询-conda-版本" class="headerlink" title="查询 conda 版本"></a>查询 conda 版本</h3><blockquote><p>conda –version</p></blockquote><h3 id="更新-conda"><a href="#更新-conda" class="headerlink" title="更新 conda"></a>更新 conda</h3><blockquote><p>conda update conda</p></blockquote><h3 id="查看conda环境详细信息"><a href="#查看conda环境详细信息" class="headerlink" title="查看conda环境详细信息"></a>查看conda环境详细信息</h3><blockquote><p>conda info</p></blockquote><h2 id="虚拟环境管理"><a href="#虚拟环境管理" class="headerlink" title="虚拟环境管理"></a>虚拟环境管理</h2><h3 id="查看当前有哪些虚拟环境"><a href="#查看当前有哪些虚拟环境" class="headerlink" title="查看当前有哪些虚拟环境"></a>查看当前有哪些虚拟环境</h3><blockquote><p>conda env list</p></blockquote><p>或者使用如下命令：</p><blockquote><p>conda info –envs</p></blockquote><h3 id="创建一个新的虚拟环境"><a href="#创建一个新的虚拟环境" class="headerlink" title="创建一个新的虚拟环境"></a>创建一个新的虚拟环境</h3><blockquote><p>conda create –name jupyter_venv python&#x3D;3.8</p></blockquote><p>其中，通过 <code>-n</code>或<code>--name</code> 来自定义的环境名称，如：<code>jupyter_venv</code>；同时，指定Python的版本。</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><blockquote><p>conda activate jupyter_venv</p></blockquote><h3 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h3><blockquote><p>conda deactivate</p></blockquote><h3 id="删除某个虚拟环境"><a href="#删除某个虚拟环境" class="headerlink" title="删除某个虚拟环境"></a>删除某个虚拟环境</h3><blockquote><p>conda remove -n your_env_name –all 其中，<code>-n</code>与<code>--name</code>等价，表示虚拟环境名</p></blockquote><h3 id="复制某个虚拟环境"><a href="#复制某个虚拟环境" class="headerlink" title="复制某个虚拟环境"></a>复制某个虚拟环境</h3><blockquote><p>conda create –name new_env_name –clone old_env_name</p></blockquote><h3 id="分享-备份一个虚拟环境"><a href="#分享-备份一个虚拟环境" class="headerlink" title="分享&#x2F;备份一个虚拟环境"></a>分享&#x2F;备份一个虚拟环境</h3><p>一个分享环境的快速方法就是给他一个你的环境的<code>.yml</code>文件。</p><p>首先激活要分享的环境，在当前工作目录下生成一个<code>environment.yml</code>文件。</p><blockquote><p>conda env export &gt; environment.yml</p></blockquote><p>对方拿到<code>environment.yml</code>文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境即可。</p><blockquote><p>conda env create -f environment.yml</p></blockquote><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><blockquote><p>conda install [package] (如：<code>conda install numpy</code>)</p></blockquote><p>指定包版本：</p><blockquote><p>conda install xlrd&#x3D;1.2.0 (注意是单等于号）</p></blockquote><p>也可以使用<code>pip install</code>安装：</p><blockquote><p>pip install xlrd==1.2.0 (注意是双等于号）</p></blockquote><h1 id="批量安装-requirements-txt-文件中包含的组件依赖"><a href="#批量安装-requirements-txt-文件中包含的组件依赖" class="headerlink" title="批量安装 requirements.txt 文件中包含的组件依赖"></a>批量安装 requirements.txt 文件中包含的组件依赖</h1><p>conda install –yes –file requirements.txt<br>复制代码</p><h3 id="批量导出依赖包"><a href="#批量导出依赖包" class="headerlink" title="批量导出依赖包"></a>批量导出依赖包</h3><p>批量导出包含环境中所有依赖包到requirements.txt文件。</p><p>conda list -e &gt; requirements.txt<br>复制代码</p><h3 id="删除当前环境中的某个包"><a href="#删除当前环境中的某个包" class="headerlink" title="删除当前环境中的某个包"></a>删除当前环境中的某个包</h3><blockquote><p>conda remove [package]</p></blockquote><p>注意：这里并非<code>conda uninstall</code>，只有在<code>pip</code>指令下才有<code>pip uninstal</code>。</p><h3 id="升级当前环境中的某个包"><a href="#升级当前环境中的某个包" class="headerlink" title="升级当前环境中的某个包"></a>升级当前环境中的某个包</h3><blockquote><p>conda update [package]</p></blockquote><p>升级所有包：</p><blockquote><p>conda update –all</p></blockquote><h3 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h3><blockquote><p>conda search [package]</p></blockquote><h3 id="删除没有用的安装包"><a href="#删除没有用的安装包" class="headerlink" title="删除没有用的安装包"></a>删除没有用的安装包</h3><p>Conda 安装的包都在目录<code>Anaconda/pkgs</code>下。随着使用，conda 安装的包也越来越多；有时候会出现以下不好的情况：</p><ul><li>有些包安装之后，从来没有使用过；</li><li>一些安装包的tar包也保留在了计算机中；</li><li>由于依赖或者环境等原因，某些包的不同版本重复安装。</li></ul><p>上面的这些情况使得anaconda显得更加冗余，并且浪费储存；对于这些情况可以使用<code>conda clean</code> 净化Anaconda。</p><blockquote><p>conda clean -p</p></blockquote><p>或者</p><blockquote><p>conda clean –packages</p></blockquote><h3 id="删除tar包"><a href="#删除tar包" class="headerlink" title="删除tar包"></a>删除tar包</h3><blockquote><p>conda clean -t</p></blockquote><p>或者</p><blockquote><p>conda clean –tarballs</p></blockquote><h3 id="删除所有的安装包及cache"><a href="#删除所有的安装包及cache" class="headerlink" title="删除所有的安装包及cache"></a>删除所有的安装包及cache</h3><p>删除索引缓存、锁定文件、未使用过的包和tar包。</p><blockquote><p>conda clean -y –all</p></blockquote><h2 id="镜像源管理"><a href="#镜像源管理" class="headerlink" title="镜像源管理"></a>镜像源管理</h2><h3 id="查看镜像源"><a href="#查看镜像源" class="headerlink" title="查看镜像源"></a>查看镜像源</h3><blockquote><p>conda config –show channels</p></blockquote><h3 id="添加镜像源"><a href="#添加镜像源" class="headerlink" title="添加镜像源"></a>添加镜像源</h3><p>如：添加清华源</p><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>复制代码</p><h3 id="配置安装包时显示安装来源"><a href="#配置安装包时显示安装来源" class="headerlink" title="配置安装包时显示安装来源"></a>配置安装包时显示安装来源</h3><blockquote><p>conda config –set show_channel_urls yes</p></blockquote><p>上面的设置表示从channel中安装包时显示channel的url，这样就可以知道包的安装来源了。</p><h3 id="清除索引缓存，保证用的是镜像站提供的索引"><a href="#清除索引缓存，保证用的是镜像站提供的索引" class="headerlink" title="清除索引缓存，保证用的是镜像站提供的索引"></a>清除索引缓存，保证用的是镜像站提供的索引</h3><blockquote><p>conda clean -i</p></blockquote><h3 id="切换回默认源"><a href="#切换回默认源" class="headerlink" title="切换回默认源"></a>切换回默认源</h3><blockquote><p>conda config –remove-key channels</p></blockquote><h3 id="移除某个镜像源"><a href="#移除某个镜像源" class="headerlink" title="移除某个镜像源"></a>移除某个镜像源</h3><p>如：移除清华源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br></code></pre></td></tr></table></figure><h3 id="临时指定安装某个包使用的镜像源"><a href="#临时指定安装某个包使用的镜像源" class="headerlink" title="临时指定安装某个包使用的镜像源"></a>临时指定安装某个包使用的镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>pip install [package] -i https://pypi.tuna.tsinghua.edu.cn/simple/<br><br>pip install [package] -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.MySQL</title>
    <link href="/posts/aaba9777/"/>
    <url>/posts/aaba9777/</url>
    
    <content type="html"><![CDATA[<h4 id="MySQL-的存储引擎有哪些？它们之间有什么区别？"><a href="#MySQL-的存储引擎有哪些？它们之间有什么区别？" class="headerlink" title="MySQL 的存储引擎有哪些？它们之间有什么区别？"></a>MySQL 的存储引擎有哪些？它们之间有什么区别？</h4><ul><li>MySql共有10个不同的存储引擎，其中最主要的为<em>InnoDB和MyISAM</em>，其他还有<em>Memory, NDB, ARCHIVE</em>, CSV, Blackhole, Merge, Federated, Example</li><li><em><strong>InnoDB</strong></em><ul><li>支持<em>事务、行级锁和外键</em>。</li><li>提供<em>高并发性能</em>，适用于高负载的 OLTP 应用。</li><li>数据以<em>聚集索引</em>的方式存储，提高检索效率</li></ul></li><li><em><strong>MyISAM</strong></em><ul><li><em>不支持事务和外键</em>，使用表级锁。</li><li>适合<em>读取多、更新少</em>的场景，如数据仓库。</li><li>具有较高的读性能和较快的表级锁定。</li></ul></li><li><em><strong>MEMORY</strong></em><ul><li>数据存储在内存中，速度快，但数据在服务器重启后丢失。</li><li>适用于临时数据存储或快速缓存。</li></ul></li><li><em><strong>NDB (NDBCluster)：</strong></em><ul><li>支持高可用性和数据分布，适合大规模分布式应用</li><li>提供行级锁和自动分区。</li></ul></li><li><em><strong>ARCHIVE</strong></em>：<ul><li>用于存储大量历史数据，支持高效的插入和压缩。</li><li>不支持索引，适合日志数据存储。</li></ul></li><li></li></ul><h4 id="InnoDB学习记录"><a href="#InnoDB学习记录" class="headerlink" title="InnoDB学习记录"></a>InnoDB学习记录</h4><ul><li><p>昨晚看了两三个多小时，依旧没把这题看完，险些道心破碎，结果今天一看，嘿，原来直接搞定了一堆题目，爽了。</p></li><li><p><em><strong>InnoDB（详细可见 <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-introduction.html">官方文档</a>）</strong></em></p><ul><li>一个兼顾高可靠性和高性能的通用存储引擎。在 MySQL 8.4 中，<code>InnoDB</code> 是默认的 MySQL 存储引擎。</li><li>主要优势：<ul><li>DML操作遵循 ACID 模型，事务具有<em>提交、回滚和崩溃恢复</em>功能，以保护用户数据</li><li><em>行级锁和 Oracle 风格的一致性读取</em>可以提高多用户并发和性能</li><li><em>聚簇索引</em>的方式可最大限度减少逐渐查找的I&#x2F;O</li><li>为了保持数据完整性，<code>InnoDB</code> 支持 <code>FOREIGN KEY</code> 约束</li></ul></li><li>数据存储结构<ul><li><em>表空间</em>：数据存储在表空间文件（<code>.ibd</code>）中，包含 <strong>数据段</strong>（存储行数据）、<strong>索引段</strong>（存储索引）和 <strong>回滚段</strong>（存储事务回滚信息）。</li><li>页：数据以固定大小的 <strong>页（16KB）</strong> 为单位存储，每个页包含行数据，页目录，页头，文件头</li></ul></li><li><em>功能</em>：<ul><li><img src="/img/Pasted_image_20250311110109.png"></li><li>基于文档中的表格，可以发现支持的索引方式有以下几种：<ul><li>B+树索引（聚簇索引）<ul><li>注意：支持聚簇索引，但是不支持聚簇数据库（cluster database support）</li></ul></li><li>全文搜索索引（也即倒排索引）</li><li>哈希索引</li><li>R-tree索引</li><li>不支持T-tree索引</li></ul></li></ul></li><li><em><strong>几个提及的相关概念在下面做详细解释</strong></em></li></ul></li><li><p><em><strong>B树和B+树</strong></em></p><ul><li>在了解<em><strong>B树</strong></em>之前，想必大家已经了解过AVL树和红黑树等，这些二叉树虽然已经能实现<code>O(logn)</code>级别的增删改查复杂度，但是我们也需要意识到，同为<code>O(logn)</code>亦有区别。</li><li>让我们看看两种数据结构的图示：<ul><li><img src="/img/Pasted_image_20250311111828.png"></li></ul></li><li>在查询时，需要先从硬盘中读取数据再做后续操作，假设需要查询有序二叉树中的F，需要查询3次才能找到对应节点，也即3次I&#x2F;O操作，<em>这种I&#x2F;O操作非常耗时，且与树的高度正相关</em>，相比而言内存中数据处理耗费的时间可以忽略不计。</li><li>那么，怎么才能减少I&#x2F;O操作呢？一种直观且自然的想法就是压缩树的高度。这就是B树的基本目标：<em>为磁盘存储优化，通过降低树的高度减少磁盘访问次数，支持随机读写</em></li><li><strong>那么B树的节点结构是怎么设计的</strong>？<ul><li>首先，每个节点最多包含m个子节点，有m-1个分支，被称为m阶B树，阶数通常由磁盘块的大小决定，例如每个节点存储一个磁盘块</li><li>非叶子节点存储键和指针，同时<em>直接存储数据</em>（注意，与B+树的一个主要区别）</li><li>所有叶子位于同一层，以此确保树的平衡性</li><li>在设计上，内部节点至少有$\lceil \frac{m}{2} \rceil$个子节点</li></ul></li><li><strong>核心操作</strong>：<ul><li>查找：从根节点开始逐层比较，找到目标数据所在子树，最后在叶子节点或内部节点找到数据</li><li>插入：在叶子节点插入，可能导致节点分裂（节点键数超过<code>n-1</code>），会在$\lceil \frac{m}{2} \rceil$处分裂，分裂后的中间键提升到父节点，如果父节点键数超过m-1，会继续向上分裂</li><li>删除：<ul><li>如果是内部节点，会用叶子节点取代内部节点的位置，从而转化为叶子节点的删除</li><li>如果删除叶子节点，当节点键数小于$\lceil \frac{m}{2} \rceil-1$，会需要借键或与兄弟节点合并</li></ul></li></ul></li><li><em><strong>B+树</strong></em><ul><li>在B树基础上进一步<em>优化了顺序访问和范围查询</em>，尤其适合<em><strong>数据库索引</strong></em></li><li>节点结构（<em>注意与B树的不同</em>）<ul><li><strong>内部节点仅存储键和指针</strong>，<strong>不存储实际数据</strong>。</li><li><strong>所有数据存储在叶子节点</strong>，叶子节点通过<em>指针</em>形成<em>双向链表，支持高效顺序扫描</em>。</li><li>叶子节点包含所有键的副本，且键值按顺序排列。</li><li>阶数类似于B树，但是数据仅存在于叶子节点</li></ul></li><li><img src="/img/Pasted_image_20250311144321.png"></li><li><strong>优点</strong><ul><li><strong>范围查询高效</strong>：叶子节点的链表结构支持线性遍历</li><li><strong>更高的扇出（Fan-out）</strong>：内部节点不存数据，可容纳更多键，树更矮，I&#x2F;O更少</li><li><strong>查询稳定性</strong>：所有查询均需访问到叶子节点，路径长度一致</li></ul></li></ul></li></ul></li><li><p><em><strong>聚簇索引和非聚簇索引</strong></em></p><ul><li>先放上聚簇索引和非聚簇索引的示意图（源自B站up<a href="https://www.bilibili.com/video/BV17D4y1e78A">猿人林克</a>）</li><li><img src="/img/Pasted_image_20250311145818.png"></li><li><img src="/img/Pasted_image_20250311150056.png"></li><li><img src="/img/Pasted_image_20250311150426.png"></li><li><strong>聚簇索引</strong>在叶子节点中记录的是每行的真实数据，非叶子节点中记录的是每行的key<ul><li>数据行的物理顺序与索引键值的逻辑顺序一致。</li><li>每个表<strong>只能有一个聚簇索引</strong>（因为数据只能按一种物理顺序存储）。</li><li>在多数数据库（如MySQL InnoDB）中，<strong>主键默认是聚簇索引</strong>。若未定义主键，则选择第一个<em>唯一非空索引（UNIQUE）</em> 替代；若无，隐式生成一个<em>隐藏的聚簇索引</em>。</li><li>优点：<ul><li><strong>范围查询高效</strong>：数据物理连续，减少磁盘I&#x2F;O</li><li><strong>排序和分组优化</strong>：若查询的 <code>ORDER BY</code> 或 <code>GROUP BY</code> 列是聚簇索引键，无需额外排序。</li><li><strong>覆盖索引优势</strong>：  若查询仅需聚簇索引列，无需回表。</li></ul></li><li>缺点<ul><li><strong>插入&#x2F;更新开销大</strong>：  插入数据到非末尾位置可能导致<strong>页分裂</strong>（Page Split），产生碎片，降低性能。</li><li><strong>维护成本高</strong>：  频繁更新的列不适合作为聚簇索引键。</li></ul></li><li>适用场景：<ul><li>主键或频繁用于范围查询的列</li><li>需要频繁排序或分组的列。</li></ul></li></ul></li><li><strong>非聚簇索引</strong>(Secondary Indexes)又被称为二级索引，除了聚簇索引外的每一个索引都会构成一个非聚簇索引树，叶子节点记录的是每行数据在聚簇索引中的key,<ul><li>数据行的物理顺序与索引键值无关。</li><li>每个表可创建<strong>多个非聚簇索引</strong>（如为不同查询条件优化）。</li><li><strong>回表（Bookmark Lookup）</strong>：  通过索引找到键值后，需根据<em>指针回表</em>查询完整数据行。（也即图中显示的到聚簇索引中查找，<em>首先通过索引定位到对应页，然后再根据行的物理地址找到所需的数据行</em>）</li><li>优点：<ul><li><strong>插入&#x2F;更新开销低</strong>：  不改变数据物理顺序，维护成本低于聚簇索引。</li><li><strong>多维度优化</strong>：  可为不同查询条件创建多个索引。</li></ul></li><li>缺点：<ul><li><strong>查询效率依赖回表</strong>：若查询字段未完全包含在索引中，需额外I&#x2F;O访问数据页。</li><li><strong>空间占用</strong>：多个索引会占用更多存储空间。</li></ul></li><li><strong>适用场景</strong><ul><li>高频查询的 <code>WHERE</code> 条件列（如用户名、商品类别）。</li><li>需要避免全表扫描的查询列。</li></ul></li></ul></li></ul></li><li><p>R-tree索引和T-tree索引</p><ul><li><strong>T-tree(事务树)</strong><ul><li>是一种专为<em>内存数据库</em>设计的高效索引结构，如如 Oracle TimesTen、SAP HANA等，结合了 <strong>AVL树</strong>（平衡二叉搜索树）和 <strong>B树</strong> 的特点。</li><li><strong>节点结构</strong>：<ul><li>每个节点包含 <strong>多个键值对</strong>（类似B树），但节点容量较小（通常为几十个键）。</li><li>每个节点维护一个 <strong>有序键值范围</strong>，并记录子节点的最小&#x2F;最大值。</li></ul></li><li><strong>优点</strong><ul><li>内存优化：减少指针数量，提高缓存利用率。</li><li>适合频繁更新的内存数据库（如实时交易系统）</li></ul></li></ul></li><li><strong>R-tree(空间索引树)</strong><ul><li>专为多维数据（如地理坐标、图形）设计的空间索引结构，支持高效范围查询</li><li><strong>节点结构</strong>：<ul><li>每个节点代表一个 <strong>最小边界矩形（MBR, Minimum Bounding Rectangle）</strong>，涵盖其子节点或数据对象的所有空间范围。</li><li>叶子节点存储实际数据对象的空间范围，非叶子节点存储子节点的MBR。</li></ul></li></ul></li></ul></li><li><p><em><strong>回到本题，继续学习InnoDB和MyISAM的区别</strong></em></p><ul><li><strong>InnoDB</strong>：现代数据库的标配，以 <strong>事务安全</strong> 和 <strong>高并发</strong> 为核心优势。</li><li><strong>MyISAM</strong>：仅适用于 <strong>读多写少</strong> 且 <strong>无需事务</strong> 的遗留场景。</li><li>事务与锁：<ul><li>InnoDB:<ul><li>支持事务的提交（COMMIT）和回滚（ROLLBACK），保证数据一致性。</li><li>默认使用 <strong>行级锁</strong>（通过索引实现），支持高并发写入。</li><li>通过 <strong>MVCC</strong>（多版本并发控制）实现非阻塞读（<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别）。</li></ul></li><li>MyISAM:<ul><li><strong>表级锁</strong>：任何写操作会锁住整个表，导致并发性能急剧下降。</li><li>高并发场景下，<code>INSERT</code> 和 <code>SELECT</code> 可能互相阻塞。</li></ul></li></ul></li><li>索引与数据存储<ul><li><strong>InnoDB</strong>：<ul><li><strong>聚簇索引</strong>：数据按主键顺序物理存储，二级索引存储主键值（需回表查询）。</li><li>建议使用 <strong>自增整数</strong>（避免页分裂）</li></ul></li><li><strong>MyISAM</strong>：<ul><li><strong>非聚簇索引</strong>：数据与索引分离，所有索引均存储数据行的物理地址（如偏移量）。</li><li>主键与普通索引无本质区别，查询时需两次寻址（索引→数据文件）</li></ul></li></ul></li><li><strong>性能与适用场景</strong><ul><li><strong>InnoDB 优势场景</strong>：<ul><li><strong>OLTP（联机事务处理）</strong>：如电商订单、支付系统，需高并发写入和事务安全。</li><li><strong>数据一致性要求高</strong>：如银行转账、库存扣减，依赖事务回滚和锁机制。</li><li><strong>大数据量范围查询</strong>：聚簇索引优化范围扫描（如 <code>WHERE date BETWEEN ...</code>）。</li></ul></li><li><strong>MyISAM 优势场景</strong>：<ul><li><strong>OLAP（联机分析处理）</strong>：如日志分析、报表统计，读多写少且无需事务。</li><li><strong>全文搜索（旧版本 MySQL）</strong>：MyISAM 早期版本全文索引性能更优（MySQL 5.6+ InnoDB 已支持）。</li><li><strong>只读或低频写入表</strong>：如静态配置表、归档数据表。</li></ul></li></ul></li><li><strong>崩溃恢复以及数据安全</strong><ul><li><strong>InnoDB</strong>：<ul><li>通过 <strong>Redo Log（重做日志）</strong> 和 <strong>Undo Log（回滚日志）</strong> 保证崩溃后数据一致。</li><li>支持 <strong>Double Write Buffer</strong> 防止部分写（Partial Write）导致数据损坏。</li></ul></li><li><strong>MyISAM</strong>：<ul><li>无事务日志，崩溃后需手动执行 <code>CHECK TABLE</code> 和 <code>REPAIR TABLE</code>。</li><li>数据损坏风险更高（如服务器意外断电可能导致表不可用）。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>事务支持</strong></td><td>✅ 支持 ACID 事务</td><td>❌ 不支持事务</td></tr><tr><td><strong>锁粒度</strong></td><td>行级锁（默认）</td><td>表级锁</td></tr><tr><td><strong>外键约束</strong></td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td><strong>崩溃恢复能力</strong></td><td>✅ 支持崩溃后自动恢复（Redo Log）</td><td>❌ 需手动修复（<code>REPAIR TABLE</code>）</td></tr><tr><td><strong>索引类型</strong></td><td>聚簇索引（数据与主键绑定）</td><td>非聚簇索引（数据与索引分离）</td></tr><tr><td><strong>MVCC（多版本并发控制）</strong></td><td>✅ 支持（通过 Undo Log 实现）</td><td>❌ 不支持</td></tr><tr><td><strong>全文索引</strong></td><td>✅ MySQL 5.6+ 支持</td><td>✅ 原生支持（较早版本）</td></tr><tr><td><strong>缓存机制</strong></td><td>缓存数据和索引（缓冲池）</td><td>仅缓存索引（Key Buffer）</td></tr><tr><td><strong>存储文件结构</strong></td><td><code>.ibd</code>（数据+索引）或共享表空间（<code>ibdata</code>）</td><td><code>.MYD</code>（数据）、<code>.MYI</code>（索引）、<code>.frm</code>（表结构）</td></tr><tr><td><strong>COUNT(*) 优化</strong></td><td>需全表扫描或统计近似值</td><td>✅ 直接返回缓存的行数（无需扫描）</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="949-MySQL-三层-B-树能存多少数据？"><a href="#949-MySQL-三层-B-树能存多少数据？" class="headerlink" title="949. MySQL 三层 B+ 树能存多少数据？"></a>949. MySQL 三层 B+ 树能存多少数据？</h4><ul><li>假设参数：<ul><li>页大小（Page Size）：在 MySQL 的 InnoDB 存储引擎中，默认的页大小是 16KB（16 * 1024 &#x3D; 16384 字节）。</li><li>键值大小（Key Size）：假设索引键值为 BIGINT 类型，占用 8 字节。</li><li>指针大小（Pointer Size）：用于指向子节点或数据记录的指针，通常占用 6 字节。</li><li>记录大小（Record Size）：假设每条数据记录占用 1024 字节（1KB）。</li></ul></li><li>对于叶子节点：存储数据，可以存储$16KB \div 1KB &#x3D; 16$条</li><li>对于第二层：一个索引占据$8+6&#x3D;14byte$ 则一页可以存储$16KB \div 14byte &#x3D; (16 \times 1024) byte \div 14byte &#x3D; 1170$</li><li>对于根节点：可以存储1170个索引</li><li>综合：$1170 \times 1170 \times 16 &#x3D; 21902400$</li><li>这也说明，当数据量超过2000万条时，需要进行分表操作</li></ul><h4 id="594-MySQL-索引的最左前缀匹配原则是什么？"><a href="#594-MySQL-索引的最左前缀匹配原则是什么？" class="headerlink" title="594. MySQL 索引的最左前缀匹配原则是什么？"></a>594. MySQL 索引的最左前缀匹配原则是什么？</h4><p>MySQL 的 <strong>最左前缀匹配原则（Leftmost Prefix Principle）</strong> 是联合索引（Composite Index）的核心使用规则，直接影响索引是否生效及查询效率。以下从 <strong>原理、示例、场景优化</strong> 三个维度详细解析：</p><hr><p><em><strong>一、原理详解</strong></em></p><ol><li><strong>联合索引的结构</strong><ul><li>假设创建联合索引 <code>INDEX idx_a_b_c (a, b, c)</code>，索引在磁盘中的存储逻辑如下：<ul><li><strong>按列顺序排序</strong>：先按 <code>a</code> 排序 → <code>a</code> 相同再按 <code>b</code> 排序 → <code>a</code> 和 <code>b</code> 都相同最后按 <code>c</code> 排序。</li><li><strong>类似电话簿</strong>：先按姓氏排序，再按名字排序，最后按城市排序。</li></ul></li></ul></li><li><strong>最左前缀规则</strong><br>查询时，<strong>必须从索引的最左列开始</strong>，且<strong>不能跳过中间的列</strong>。以下情况索引可能生效：<br>- 使用 <code>a</code> 列 → ✅<br>- 使用 <code>a + b</code> → ✅<br>- 使用 <code>a + b + c</code> → ✅<br>- 使用 <code>a + c</code> → ⚠️ <strong>部分生效</strong>（仅 <code>a</code> 生效，<code>c</code> 不生效）<br>- 使用 <code>b</code> 或 <code>c</code> 或 <code>b + c</code> → ❌ 不生效</li><li><strong>底层原因</strong><ul><li><strong>索引有序性</strong>：索引按 <code>(a, b, c)</code> 的顺序构建，跳过左列会导致后续列无序，无法利用二分查找。</li><li><strong>B+树结构</strong>：非最左列的查询需遍历整个索引树，效率可能不如全表扫描。</li></ul></li></ol><hr><p>二、示例分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#  示例表结构<br>CREATE TABLE users (<br>    id INT PRIMARY KEY,<br>    country VARCHAR(50),<br>    city VARCHAR(50),<br>    age INT,<br>    INDEX idx_country_city_age (country, city, age)<br>);<br></code></pre></td></tr></table></figure><ol><li><p><strong>生效的查询场景</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- ✅ 使用最左列 country</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span>;<br><br><span class="hljs-comment">-- ✅ 使用 country + city</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br><br><span class="hljs-comment">-- ✅ 使用 country + city + age（全列匹配）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Beijing&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>部分生效的场景</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- ⚠️ 仅 country 生效，age 无法走索引（中间跳过了 city）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">-- ⚠️ 范围查询后，后续列无法走索引（city=&#x27;Beijing&#x27; 生效，但 age 不生效）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <br><span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> city <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>; <span class="hljs-comment">-- 仅 country + city 生效</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不生效的场景</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- ❌ 未使用最左列 country</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Beijing&#x27;</span>;<br><br><span class="hljs-comment">-- ❌ 跳过了中间列 city</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>如果遇到范围查询(&gt;、&lt;)，就会停止匹配</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">where a&gt;1, b=2, c=3;<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>所谓的停止匹配指的是：a 可以用上联合索引，但是 b 和 c 却不行。因为 a 需要先经过范围查询，此时经过筛选得到 b 和 c 的数据是无序的。比如 a 为 1 和 a 为 2 数据之间 b 和 c 是无序的，因此无法利用索引查询。</p></li><li><p><strong>如果遇到如 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、前缀like（xx%）的范围查询，则不会停止匹配</strong>。因为这些查询包含一个等值判断，可以直接定位到某个数据，然后往后扫描即可。</p></li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">where a&gt;=1, b=2, c=3;<br></code></pre></td></tr></table></figure><ul><li><p>查询可以定位到 a&#x3D;1 这条数据，然后往后遍历即可，而定<strong>位到的 a&#x3D;1 数据内，b 和 c 是有序的，因此可以利用索引查询</strong>。</p></li><li><p>而以下的查询则可以全部用上联合索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">where a=1, b=2, c&gt;3;<br></code></pre></td></tr></table></figure></li><li><p>因为 a 和 b 是等值查询的情况下，c 是有序的，有序就可以用上索引。</p></li></ul><hr><p>三、场景优化策略</p><ol><li><strong>合理设计联合索引顺序</strong></li></ol><ul><li><strong>高频查询条件在前</strong>：将最常用的列放在索引左侧。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 假设查询条件多为 country + city，而非单独 country</span><br>INDEX idx_country_city (country, city);<br></code></pre></td></tr></table></figure><ul><li><strong>区分度高的列在前</strong>：区分度高的列（唯一值多）能更快缩小查询范围。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- country 有 100 个值，city 有 1000 个值 → 优先 city 在前？</span><br><span class="hljs-comment">-- 错误！必须结合查询条件频率，不能只看区分度。</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>处理范围查询</strong></li></ol><ul><li><strong>范围查询后的列无法走索引</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引: (country, city, age)</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <br><span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> city <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;Beijing&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-comment">-- 实际生效索引：country + city（age 无法利用索引）</span><br></code></pre></td></tr></table></figure></li><li><strong>优化方案</strong>：将等值查询列放在范围查询列之前。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 如果查询条件多为 country + age，且 age 是范围查询：</span><br><span class="hljs-comment">-- 需要重新设计索引，但受最左前缀限制，可能需要单独创建 (country, age) 索引。</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>覆盖索引优化</strong></li></ol><ul><li><strong>无需回表</strong>：若查询字段全部在索引中，即使跳过中间列，也可能触发覆盖索引。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引: (country, city, age)</span><br><span class="hljs-keyword">SELECT</span> country, city, age <span class="hljs-keyword">FROM</span> users <br><span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>; <span class="hljs-comment">-- ⚠️ 使用覆盖索引（Extra: Using index）</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>索引下推（Index Condition Pushdown, ICP）</strong></li></ol><ul><li><strong>MySQL 5.6+ 特性</strong>：将 <code>WHERE</code> 条件中索引列的过滤下推到存储引擎层。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引: (country, city, age)</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <br><span class="hljs-keyword">WHERE</span> country <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;China&#x27;</span> <span class="hljs-keyword">AND</span> city <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;B%&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br><span class="hljs-comment">-- 即使 city 是模糊查询，ICP 会在引擎层过滤 age=25 的记录，减少回表次数。</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="593-MySQL中的回表是什么"><a href="#593-MySQL中的回表是什么" class="headerlink" title="593.MySQL中的回表是什么"></a>593.MySQL中的回表是什么</h4><ul><li>“回表” 是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，<strong>这个过程被称为回表</strong>。</li><li>回表其实不仅仅只是多查一次，<strong>还会带来随机 I&#x2F;O</strong>。</li><li>因为通过 id 去主键索引查询的时候，id 肯定是不连续的（例如 age 为 20 的人很多，age 索引中年龄是有序的，但是 id 无序，且是不连续的），所以去主键索引频繁查询会造成大量随机 I&#x2F;O ，我们都知道顺序 I&#x2F;O 查询快，而随机 I&#x2F;O 慢，所以频繁回表效率很低。</li><li>因此，不要因为图方便，在代码里都用 select * ，从而引发不必要的回表操作。</li><li><em><strong>覆盖索引</strong></em><ul><li>指<strong>查询的列完全包含在某个索引中</strong>，数据库可以直接通过索引返回结果，无需回表（即无需访问数据行）。这种优化可显著减少磁盘 I&#x2F;O，提升查询性能。</li><li>假设有一个联合索引<code>INDEX idx_age_city (age, city)</code>,</li><li><img src="/img/Pasted%20image%2020250312132622.png"></li></ul></li><li><em><strong>索引下推(Index Condition Pushdown，简称 ICP)</strong></em><ul><li>MySQL的大概架构：<ul><li><img src="/img/Pasted%20image%2020250312132750.png"></li></ul></li><li><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</li><li><strong>注意：索引下推是应用在<em>联合索引</em>上的。</strong></li><li>对<em>InnoDB和MYISAM</em>两个存储引擎都生效</li><li>我们来具体看一下，在<em>没有使用ICP</em>的情况下，MySQL的查询：<ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul></li><li><em>使用ICP</em>的情况下，查询过程：<ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul></li><li><em><strong>Using index</strong></em>：表示查询可以完全通过索引来获取数据，不需要访问数据表的行（即 “索引覆盖”）。这种情况性能较好，因为只访问了索引，没有读表。</li><li><em><strong>Using index condition</strong></em>：表示 MySQL 只使用了索引进行部分过滤，但仍然需要读取表中的数据行。虽然通过索引进行了一定的优化，但相比完全使用索引，性能会略逊一筹。</li></ul></li></ul><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐操作</strong></th></tr></thead><tbody><tr><td>高频等值查询</td><td>建 B-Tree 索引，优先选择高选择性列。</td></tr><tr><td>范围查询 + 排序</td><td>复合索引按等值列在前、范围列在后。</td></tr><tr><td>避免回表</td><td>使用覆盖索引。</td></tr><tr><td>长字符串列</td><td>使用前缀索引。</td></tr><tr><td>数据频繁更新</td><td>减少索引数量，避免在频繁修改的列上建索引。</td></tr></tbody></table><ol><li><p><strong>只为高频查询列建索引</strong></p><ul><li>索引会占用存储空间，且增删改操作需维护索引，<strong>避免过度索引</strong>。</li><li>优先为高频查询的 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 涉及的列建索引。</li></ul></li><li><p><strong>选择合适索引类型</strong></p><ul><li><strong>B-Tree 索引</strong>：默认类型，支持范围查询（<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>）、排序和前缀匹配。</li><li><strong>哈希索引</strong>：仅支持等值查询（<code>=</code>），适用于内存表（Memory Engine）。</li><li><strong>全文索引</strong>：用于文本字段的全文搜索（<code>MATCH ... AGAINST</code>）。</li><li><strong>空间索引</strong>：用于地理数据（如 <code>GEOMETRY</code> 类型）。</li></ul></li><li><p><strong>利用最左前缀原则</strong></p><ul><li>复合索引 <code>(a, b, c)</code> 生效的场景：<ul><li><code>WHERE a=1</code></li><li><code>WHERE a=1 AND b=2</code></li><li><code>WHERE a=1 AND b=2 AND c=3</code></li></ul></li><li><strong>失效的场景</strong>：<ul><li><code>WHERE b=2</code>（未使用最左列 <code>a</code>）</li><li><code>WHERE a=1 AND c=3</code>（跳过中间列 <code>b</code>）</li></ul></li></ul></li></ol><h4 id="MySQL中使用索引一定有效吗"><a href="#MySQL中使用索引一定有效吗" class="headerlink" title="MySQL中使用索引一定有效吗"></a>MySQL中使用索引一定有效吗</h4><table><thead><tr><th><strong>场景</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>低选择性索引</strong></td><td>索引列的值重复率高（如性别、状态字段），优化器认为全表扫描更快。</td></tr><tr><td><strong>索引列参与运算或函数</strong></td><td>例如 <code>WHERE YEAR(create_time) = 2023</code>，索引无法直接使用。</td></tr><tr><td><strong>隐式类型转换</strong></td><td>例如字符串列使用数字查询（<code>WHERE id = &#39;100&#39;</code>），导致索引失效。</td></tr><tr><td><strong>未遵循最左前缀原则</strong></td><td>复合索引 <code>(a, b, c)</code> 的查询跳过最左列 <code>a</code>，如 <code>WHERE b=2</code>。</td></tr><tr><td><strong>范围查询中断索引连续性</strong></td><td>范围查询（如 <code>a &gt; 10</code>）后，复合索引后续列的过滤条件无法直接使用索引。</td></tr><tr><td><strong>使用 <code>!=</code>、<code>NOT IN</code></strong></td><td>非等值查询无法有效利用索引。</td></tr><tr><td><strong>小表查询</strong></td><td>数据量较少时，优化器可能选择全表扫描而非索引。</td></tr><tr><td><strong>统计信息不准确</strong></td><td>索引的基数（Cardinality）统计不准确，导致优化器误判索引效率。</td></tr><tr><td><strong>1. 使用 <code>EXPLAIN</code> 分析执行计划</strong></td><td></td></tr><tr><td>通过 <code>EXPLAIN</code> 查看查询是否命中索引及索引使用细节：</td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure><p><strong>关键字段解析</strong>：</p><ul><li>**<code>type</code>**：访问类型，优先级从高到低：<br>  <code>const &gt; ref &gt; range &gt; index &gt; ALL</code>（<code>ALL</code> 表示全表扫描）。</li><li>**<code>key</code>**：实际使用的索引名称。</li><li>**<code>rows</code>**：预估扫描的行数，值越小越好。</li><li>**<code>Extra</code>**：额外信息，重点关注：<ul><li><code>Using index</code>：覆盖索引，无需回表。</li><li><code>Using where</code>：存储引擎层无法直接过滤，需 Server 层处理。</li><li><code>Using filesort</code>：需要额外排序，可能需优化索引或查询。</li></ul></li><li><a href="https://www.mianshiya.com/question/1780933295463231490">看这篇题解，非常好</a></li></ul><h4 id="599-MySQL-中的索引数量是否越多越好？为什么？"><a href="#599-MySQL-中的索引数量是否越多越好？为什么？" class="headerlink" title="599. MySQL 中的索引数量是否越多越好？为什么？"></a>599. MySQL 中的索引数量是否越多越好？为什么？</h4><ul><li><p><strong>索引并不是越多越好</strong>。因为索引<strong>不论从时间还是空间上都是有一定成本的</strong></p></li><li><p><strong>1）从时间上</strong></p><ul><li>每次对表中的数据进行增删改(INSERT、UPDATE 或 DELETE)的时候，索引也必须被更新，这会增加写入操作的开销。例如删除了一个 name 为面试鸭的记录，不仅主键索引上需要修改，如果 name 字段有索引，那么 name 索引也需要修改，所以<strong>索引越多需要修改的地方也就越多，时间开销就大了</strong>，并且 B+ 树可能会有页分裂、合并等操作，时间开销就会更大。</li><li>还有一点需要注意：MySQL 有个查询优化器，它需要分析当前的查询，选择最优的计划，这过程就需要考虑选择哪个索引的查询成本低。如果索引过多，那么会导致优化器耗费更多的时间在选择上，甚至可能因为数据的不准确而选择了次优的索引。</li></ul></li><li><p><strong>2）从空间上</strong></p><ul><li>每建立一个二级索引，都需要新建一个 B+ 树，默认每个数据页都是 16kb，如果数据量很大，索引又很多，占用的空间可不小。</li></ul></li></ul><h4 id="612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？"><a href="#612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？" class="headerlink" title="612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？"></a>612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？</h4><ul><li><em><strong>回答重点</strong></em><ul><li>explain 主要用来 SQL 分析，它主要的属性详解如下：</li><li><code>id</code>：查询的执行顺序的标识符，值越大优先级越高。简单查询的 id 通常为 1，复杂查询（如包含子查询或 UNION）的 id 会有多个。</li><li><code>select_type</code>（<strong>重要</strong>）：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。</li><li><code>table</code>：查询的数据表。</li><li><code>type</code>（<strong>重要</strong>）：访问类型，如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）等。一般来说，性能从好到差的顺序是：const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。</li><li><code>possible_keys</code>：可能用到的索引。</li><li><code>key</code>（<strong>重要</strong>）：实际用到的索引。</li><li><code>key_len</code>：用到索引的长度。</li><li><code>ref</code>：显示索引的哪一列被使用。</li><li><code>rows</code>（<strong>重要</strong>）：估计要扫描的行数，值越小越好。</li><li><code>filtered</code>：显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。</li><li><code>Extra</code>（<strong>重要</strong>）：额外信息，如 <code>Using index</code>（表示使用覆盖索引）、<code>Using where</code>（表示使用 WHERE 条件进行过滤）、<code>Using temporary</code>（表示使用临时表）、<code>Using filesort</code>（表示需要额外的排序步骤）。</li></ul></li><li><em><strong>type 详解：</strong></em><ul><li>system：表示查询的表只有一行（系统表）。这是一个特殊的情况，不常见。</li><li>const：表示查询的表最多只有一行匹配结果。这通常发生在查询条件是<strong>主键</strong>或<strong>唯一索引</strong>，并且是常量比较。</li><li>eq_ref：表示对于每个来自前一张表的行，MySQL 仅访问一次这个表。这通常发生在连接查询中使用主键或唯一索引的情况下。</li><li>ref：MySQL 使用非唯一索引扫描来查找行。查询条件使用的索引是非唯一的（如普通索引）。</li><li>range：表示 MySQL 会扫描表的一部分，而不是全部行。范围扫描通常出现在使用索引的范围查询中（如 <code>BETWEEN</code>、<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>）。</li><li>index：表示 MySQL 扫描索引中的所有行，而不是表中的所有行。即使索引列的值覆盖查询，也需要扫描整个索引。</li><li>all（性能最差）：表示 MySQL 需要扫描表中的所有行，即全表扫描。通常出现在没有索引的查询条件中。</li></ul></li></ul><h4 id="616-MySQL-中如何进行-SQL-调优？"><a href="#616-MySQL-中如何进行-SQL-调优？" class="headerlink" title="616. MySQL 中如何进行 SQL 调优？"></a>616. MySQL 中如何进行 SQL 调优？</h4><ul><li><p><em><strong>回答重点</strong></em></p><ul><li>平时进行 SQL 调优，主要是通过观察慢 SQL，然后利用 explain 分析查询语句的执行计划，识别性能瓶颈，优化查询语句。</li></ul><ol><li><p>合理设计索引，利用联合索引进行覆盖索引的优化，避免回表的发生，减少一次查询和随机 I&#x2F;O</p></li><li><p>避免 SELECT * ，只查询必要的字段</p></li><li><p>避免在 SQL 中进行函数计算等操作，使得无法命中索引</p></li><li><p>避免使用 %LIKE，导致全表扫描</p></li><li><p>注意联合索引需满足最左匹配原则</p></li><li><p>不要对无索引字段进行排序操作</p></li><li><p>连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描</p></li></ol></li><li><p>除此之外，还可以<strong>利用缓存</strong>来优化，一些变化少或者访问频繁的数据设置到缓存中，减轻数据库的压力，提升查询的效率。</p></li><li><p>还可以<strong>通过业务</strong>来优化，例如少展示一些不必要的字段，减少多表查询的情况，将列表查询替换成分页分批查询等等。</p></li><li><p><em><strong>扩展知识–慢 SQL</strong></em></p><ul><li><p>这是 MySQL 自带的日志记录，默认关闭，通过 <code>set global slow_query_log = &#39;ON&#39;</code> 即可开启。</p></li><li><p>通过 <code>show variables like &#39;%slow_query_log%&#39;</code> 即可查询当前慢日志是否开启，以及存储的路径。</p></li><li><p>通过 <code>set global long_query_time = 3</code> 即可设置慢 SQL 的阈值，3 就是 3 秒，当一个 SQL 执行的时间操作 3 秒，就会被记录到慢日志中。</p></li></ul></li></ul><h4 id="613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？"><a href="#613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？" class="headerlink" title="613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？"></a>613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</h4><ul><li><em><strong>功能上</strong></em>：<ul><li>1）<code>count(*)</code> 会统计表中所有行的数量，包括 <code>null</code> 值（不会忽略任何一行数据）。由于只是计算行数，不需要对具体的列进行处理，因此性能通常较高。</li><li>2）<code>count(1)</code> 和 <code>count(*)</code> 几乎没差别，也会统计表中所有行的数量，包括 <code>null</code> 值。</li><li>3）<code>count(字段名)</code> 会统计指定字段不为 <code>null</code> 的行数。这种写法会对指定的字段进行计数，只会统计字段值不为 <code>null</code> 的行。</li></ul></li><li><em><strong>效率上</strong></em>：<ul><li><code>count(1)</code> 和 <code>count(*)</code> 效率一致</li><li><code>count(字段)</code> 的查询就是全表扫描(如果对应的字段没有索引，如果有索引则用索引)，正常情况下它还需要判断字段是否是 null 值，因此理论上会比 <code>count(1)</code> 和 <code>count(*)</code> 慢。</li><li>但是如果字段不为 null，例如是主键，那么理论上也差不多，而且本质上它们的统计功能不一样，在需要统计 null 的时候，只能用 <code>count(1)</code> 和 <code>count(*)</code>，不需要统计 null 的时候只能用<code>count(字段)</code>，所以也不用太纠结性能问题。</li></ul></li><li><em><strong>扩展知识</strong></em><ul><li><p>在 MyISAM 中，由于只有表锁，因此它把每张表的总数单独记录维护（表锁使得对表的修改是串行，因此能维护总数），所以 <code>count(*)</code> 非常快，因为等于直接返回一个字段。当然，<strong>前提是不需要条件过滤而是直接返回整表数据</strong>。</p></li><li><p>而 InnoDB 由于支持行锁，所以会有很多并发来修改表的数据，因此无法维护记录总数，但是 InnoDB 对<code>count(*)</code>和<code>count(1)</code>也做了一定的优化。</p></li><li><p>count 的字段如果是主键，由于主键索引保存的是整行记录，占据的空间和内存都比较大，此时表中如果还有其它二级索引，那么成本会更低，因此 InnoDB 会评估这个成本选择合适的索引扫描。当然，这个前提也是不能有对应的条件过滤等功能。</p></li></ul></li><li><img src="/img/Pasted_image_20250314103948.png"></li><li><img src="/img/Pasted_image_20250314104003.png"></li></ul><h4 id="615-MySQL-中-varchar-和-char-有什么区别？"><a href="#615-MySQL-中-varchar-和-char-有什么区别？" class="headerlink" title="615. MySQL 中 varchar 和 char 有什么区别？"></a>615. MySQL 中 varchar 和 char 有什么区别？</h4><ul><li><p><img src="/img/Pasted_image_20250314105731.png"></p></li><li><p>理论上来说 CHAR 会比 VARCHAR 快，因为 VARCHAR 长度不固定，处理需要多一次运算，但是实际上这种运算耗时微乎其微，而固定大小在很多场景下比较浪费空间，除非存储的字符确认是固定大小或者本身就很短，不然业务上推荐使用 VARCHAR。</p></li><li><p><em><strong>拓展</strong></em></p><ul><li><p>MySQL 执行 orderby 排序的时候，会利用 sort_buffer。</p></li><li><p>假设 a、b、c 都为 varchar 类型，当前要执行<code>select a,b,c from t1 where a = &#39;面试鸭&#39; order by b;</code></p></li><li><p>MySQL 计算 a b c 总长度比较长，sort_buffer 可能放不下，就会使用<strong>双路排序</strong>，即 sort_buffer 里存放需要排序的字段 b 和 id 进行排序，待排完后，再通过 id 回表查询得到a、b、c 字段。这样就多了回表的一步，性能比较差。</p></li><li><p><img src="/img/Pasted_image_20250314110644.png"></p></li><li><p>如果 select 字段长度少，那么就可以使用<strong>单路排序</strong>，即将 select 的数据都放入到 sort_buffer 中，排完序后直接返回给客户端。</p></li><li><p><img src="/img/Pasted_image_20250314110659.png"></p></li><li><p>这里计算 a、b、c 长度依据的就是 varchar(n) 中的 n，所以如果 n 设置很大，虽然占用空间是动态的，但是会隐性影响排序的性能。</p></li></ul></li><li><p><em><strong>varchar支持的最大长度</strong></em></p><blockquote><p>mysql column length is within the maximum length of 65,535 bytes</p></blockquote></li><li><p>因为最大行长度有限，所以要计算 VARCHAR 支持最大长度，仅当一行只有一个 VARCHAR 字段时，这个 VARCHAR 字段能达到最大长度（没有别的字段来占用空间）。</p></li><li><p>最大行长度是 65535 字节，如果值允许为 null，则需要额外 1bit 标记是否为 null（mysql 最对于 null 值是额外用一个 null值列表存储的。当前只有一个 VARCHAR 字段，需要用 1 个 bit 标记它的 null 值组成 null 值列表，mysql 要求 null 值列表最少需要一个字节，所以需要占用 1 个字节），又因为 VARCHAR 列的长度是可变的，需要 1 到 2 个字节（字符长度超过 255，则使用两个字节）用于存储字符串的长度信息。</p></li><li><p>所以支持的最大长度是 <code>65535 - 2 = 65533</code>，如果允许为 null 则是 <code>65532</code>。</p></li><li><p>以上是字节数，实际的字符又取决于使用的字符集。</p><ul><li>UTF-8 字符集：每个字符最大占用 3 字节（但也可以是 1 字节、2 字节或 3 字节，具体取决于字符的实际编码）。因此，最大字符数会受限于字符集的编码方式。如果使用 UTF-8，最大字符数大约是 21844 字符（65533 ÷ 3）。</li><li>UTF-16 字符集：每个字符通常占用 2 字节。最大字符数大约是 32766 字符（65533 ÷ 2）。</li><li>Latin1 字符集：每个字符占用 1 字节，所以最大字符数为 65533 字符。</li></ul></li><li><p>在定义 <code>VARCHAR(n)</code> 时，n 代表的是字符的个数，而不是字节数。</p></li></ul><h4 id="600-请详细描述-MySQL-的-B-树中查询数据的全过程"><a href="#600-请详细描述-MySQL-的-B-树中查询数据的全过程" class="headerlink" title="600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程"></a>600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程</h4><p>1）数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点<br>2）叶子节点存储实际的数据行记录，但是一页有 16kb 大小，存储的数据行不止一条<br>3）叶子节点中数据行以组的形式划分，利用<strong>页目录</strong>结构，通过二分查找可以定位到对应的组<br>4）定位组后，利用链表遍历就可以找到对应的数据行</p><ul><li><em><strong>详细流程</strong></em><ul><li><p>数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点。</p></li><li><p><img src="/img/Pasted_image_20250314112930.png"></p></li><li><p>定位到叶子节点后，因为一片叶子默认有 16k 大小，所以理论上可以存多条记录。叶子节点的实际构造如下图所示：</p></li><li><p><img src="/img/Pasted_image_20250314112940.png"></p></li><li><p>从上图可以知晓，叶子节点有<strong>页目录</strong>结构，它其实就是一个索引，通过它可以快速找到记录。</p></li><li><p>页目录分为了多个槽，每个槽都指向对应一个分组内的最大记录，每个分组内都会包含若干条记录。</p></li><li><p>通过<strong>二分查询</strong>，利用槽就能直接定位到记录所在的组，从而就能获取到对应的记录。</p></li><li><p>举个例子，现在有 5 个槽，如果想查找主键为 3 的记录，此时的流程是：</p></li><li><p>1）通过二分得到槽的中间位置，<code>low = 0</code>，<code>high = 4</code>，<code>（0+4)/2 = 2</code>; </p></li><li><p>2）通过槽定位到第二个分组中的主键为 4 的记录，4 大于 3，<code>low = 0</code> 不变，<code>high = 2</code>; </p></li><li><p>3）继续二分 <code>(0+2)/2 = 1</code>; 槽 1 中主键 2 小于 3，<code>low = 1</code>，<code>high = 2</code>; </p></li><li><p>4）此时 <code>high - low = 1</code>，可以确定值在 high 即槽 2 中，但是槽 2 只能定位到主键为 4 的记录，又因为槽之间是挨着的，所以可以得到槽 1 的位置，从槽 1 入手拿到 主键 2 的记录，然后因为记录是通过单向链表串起来的，往下遍历即可定位到主键 3 的记录。</p></li><li><p>以上就是利用二分查询的定位流程。通过槽可找到对应记录所在的组，或能直接定位到记录，或还需通过链表遍历找到对应的数据。</p></li><li><p>实际上，每个分组的记录数是有规定的，图中做了省略只画了两条，InnoDB 规定：</p><ul><li>第一个分组只有一条记录</li><li>中间的分组 4-8 条记录</li><li>最后一个分组 1-8 条记录</li></ul></li><li><p>因此不必担心遍历很长的链表导致性能问题。</p></li></ul></li></ul><h4 id="602-MySQL-是如何实现事务的？"><a href="#602-MySQL-是如何实现事务的？" class="headerlink" title="602. MySQL 是如何实现事务的？"></a>602. MySQL 是如何实现事务的？</h4><h4 id="604-MySQL-中的-MVCC-是什么？"><a href="#604-MySQL-中的-MVCC-是什么？" class="headerlink" title="604. MySQL 中的 MVCC 是什么？"></a>604. MySQL 中的 MVCC 是什么？</h4><h4 id="106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？"><a href="#106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？" class="headerlink" title="106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？"></a>106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？</h4>]]></content>
    
    
    <categories>
      
      <category>面试八股题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>#MySQL</tag>
      
      <tag>#八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
