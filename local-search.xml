<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<ul><li>前端界面初始化后出现格式乱码，挤在页面中央等情况：<ul><li>初始化的css文件是否已经完全删除？</li></ul></li></ul><hr><p>- </p>]]></content>
    
    
    <categories>
      
      <category>debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debug</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot注解</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="TableLogic"><a href="#TableLogic" class="headerlink" title="@TableLogic"></a><code>@TableLogic</code></h4><ul><li><strong>MyBatis-Plus 框架</strong> 中提供的一个注解，用于实现数据库的 ​<strong>逻辑删除</strong> 功能。它的核心作用是将数据标记为“已删除”状态（而不是物理删除数据），从而保留数据完整性和可追溯性。</li><li><strong><code>@TableLogic</code> 的用途</strong>: 通过该注解，​<strong>MyBatis-Plus 会自动实现以下逻辑</strong>：<ol><li>​<strong>删除操作</strong>：将 <code>DELETE</code> 语句转换为 <code>UPDATE</code>，修改标记字段的值。</li><li>​<strong>查询操作</strong>：自动在查询条件中添加 <code>WHERE is_deleted = 0</code>，排除已删除数据。</li><li>​<strong>数据恢复</strong>：通过更新标记字段的值，恢复被逻辑删除的数据。</li></ol></li><li><em><strong>注意！！！</strong></em>：必须增加<code>@TableLogic</code>注解，MyBatis才能识别该变量用于判断<em>逻辑删除</em><br><strong>（1）基本用法</strong><br>在实体类中标记逻辑删除字段：</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@TableId</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token annotation punctuation">@TableLogic</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> isDeleted<span class="token punctuation">;</span> <span class="token comment">// 逻辑删除标记字段</span><span class="token punctuation">&#125;</span></code></pre><p><strong>​（2）自定义删除标记值</strong></p><ul><li><p>默认值：</p><ul><li>​<strong>未删除</strong>：<code>0</code></li><li>​<strong>已删除</strong>：<code>1</code></li></ul></li><li><p>通过注解属性自定义：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableLogic</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">,</span> delval <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">)</span>  <span class="token comment">// 未删除=0，已删除=1</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> status<span class="token punctuation">;</span></code></pre></li><li><p>支持其他类型（如字符串）：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableLogic</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"NO"</span><span class="token punctuation">,</span> delval <span class="token operator">=</span> <span class="token string">"YES"</span><span class="token punctuation">)</span>  <span class="token comment">// 未删除="NO"，已删除="YES"</span><span class="token keyword">private</span> <span class="token class-name">String</span> isDeleted<span class="token punctuation">;</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目开发杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发杂记</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发工具类（减少造轮子）</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="Java自带"><a href="#Java自带" class="headerlink" title="Java自带"></a>Java自带</h2><h3 id="CollectionsUtils"><a href="#CollectionsUtils" class="headerlink" title="CollectionsUtils"></a>CollectionsUtils</h3><ul><li>用于简化集合（<code>Collection</code>、<code>List</code>、<code>Map</code> 等）的操作。它封装了多种集合操作的静态方法，可以安全处理空集合、实现集合的过滤、转换、合并等逻辑，避免开发者重复编写底层代码。</li></ul><h4 id="核心功能与用法"><a href="#核心功能与用法" class="headerlink" title="核心功能与用法"></a>核心功能与用法</h4><ul><li><p><strong>​（1）判断集合是否为空</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections4<span class="token punctuation">.</span></span><span class="token class-name">CollectionUtils</span></span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isEmpty <span class="token operator">=</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isNotEmpty <span class="token operator">=</span> <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></li><li><p>​<strong>​（2）集合的交集、并集、差集</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listA <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> listB <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 交集：两个集合都包含的元素</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> intersection <span class="token operator">=</span>     <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">intersection</span><span class="token punctuation">(</span>listA<span class="token punctuation">,</span> listB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["b", "c"]</span><span class="token comment">// 并集：合并两个集合的所有元素（去重）</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> union <span class="token operator">=</span>     <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>listA<span class="token punctuation">,</span> listB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["a", "b", "c", "d"]</span><span class="token comment">// 差集：A 中有但 B 中没有的元素</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> subtract <span class="token operator">=</span>     <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>listA<span class="token punctuation">,</span> listB<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["a"]</span></code></pre></li><li><p>​**（3）过滤集合元素 **</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> numbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 过滤出偶数</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> n <span class="token operator">-></span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// numbers 变为 [2, 4]（直接修改原集合！）</span></code></pre></li><li><p><strong>（4）集合转换</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> strings <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将字符串转换为整数</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> integers <span class="token operator">=</span>     <span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> s <span class="token operator">-></span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span></code></pre></li><li><p><strong>​（5）安全处理空集合</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 避免空指针异常</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"集合为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h4 id="回忆：Java-中的集合框架（Java-Collections-Framework）​"><a href="#回忆：Java-中的集合框架（Java-Collections-Framework）​" class="headerlink" title="回忆：Java 中的集合框架（Java Collections Framework）​"></a>回忆：Java 中的集合框架（Java Collections Framework）​</h4><ul><li>​<strong>根接口</strong>：<code>Collection&lt;E&gt;</code>，定义了集合的基本操作。</li><li>​<strong>核心子接口</strong>：</li></ul><table><thead><tr><th>接口</th><th>说明</th><th>常见实现类</th></tr></thead><tbody><tr><td>​<strong>List</strong></td><td>有序集合，允许重复元素</td><td><code>ArrayList</code>, <code>LinkedList</code></td></tr><tr><td>​<strong>Set</strong></td><td>无序集合，元素唯一</td><td><code>HashSet</code>, <code>TreeSet</code></td></tr><tr><td>​<strong>Queue</strong></td><td>队列，先进先出（FIFO）或优先队列</td><td><code>LinkedList</code>, <code>PriorityQueue</code></td></tr><tr><td>​<strong>Deque</strong></td><td>双端队列，支持两端插入和删除</td><td><code>ArrayDeque</code></td></tr></tbody></table><ul><li>​<strong>示例代码</strong>：  <pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// List 示例：允许重复，按插入顺序存储</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 允许重复</span><span class="token comment">// Set 示例：元素唯一，无序</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 重复元素会被忽略</span><span class="token comment">// 遍历集合</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> fruit <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><ul><li><strong>MyBatis-Plus（MP）​</strong> 框架中用于动态构建 SQL 查询条件的核心工具类。它通过链式调用方法（如 <code>eq()</code>, <code>like()</code>, <code>between()</code> 等）生成 <code>WHERE</code> 子句，替代手写 SQL，提升开发效率和代码可读性。</li></ul><h4 id="使用步骤（Spring-Boot-MyBatis-Plus）"><a href="#使用步骤（Spring-Boot-MyBatis-Plus）" class="headerlink" title="使用步骤（Spring Boot + MyBatis-Plus）"></a>使用步骤（Spring Boot + MyBatis-Plus）</h4><ul><li><p>​<strong>步骤 1：添加 MyBatis-Plus 依赖</strong>，在 <code>pom.xml</code> 中引入依赖：</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.5.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token comment">&lt;!-- 使用最新版本 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p><strong>步骤 2：定义实体类</strong><br>假设有一个 <code>User</code> 表，对应实体类如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span> <span class="token comment">// 表名映射（若表名与类名一致可省略）</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span> <span class="token comment">// 主键自增</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>​<strong>步骤 3：创建 Mapper 接口</strong><br>继承 <code>BaseMapper</code>，获得 MyBatis-Plus 的 CRUD 方法：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 可自定义 SQL 方法（此处不写，直接使用 BaseMapper 的方法）</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>​<strong>步骤 4：在 Service 或 Controller 中使用 QueryWrapper</strong><br>通过 <code>QueryWrapper</code> 构建查询条件，并调用 <code>selectList()</code>, <code>selectOne()</code>, <code>update()</code>, <code>delete()</code> 等方法。</p></li></ul><h4 id="​核心方法及示例"><a href="#​核心方法及示例" class="headerlink" title="​核心方法及示例"></a>​核心方法及示例</h4><p><strong>​（1）基础查询</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span><span class="token comment">// 查询所有 age > 18 的用户</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersByAge</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// age > 18</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 查询 username = "张三" 的用户</span><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>​（2）复杂条件组合</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 查询 age 在 20-30 之间，且 email 包含 "example.com" 的用户</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersByCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">,</span> <span class="token string">"example.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 查询 username 以 "张" 开头，或 age &lt; 18 的用户</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersByOr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">likeRight</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"张"</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">lt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>​<strong>​（3）排序和分页</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 按 age 降序排序</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersOrderByAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">orderByDesc</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 分页查询（需配置 MyBatis-Plus 分页插件）</span><span class="token keyword">public</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersByPage</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> pageNum<span class="token punctuation">,</span> <span class="token class-name">Integer</span> pageSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>pageNum<span class="token punctuation">,</span> pageSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p> ​<strong>​（4）更新和删除</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 将 age > 30 的用户 email 设为 null</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateUsersEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 删除 username 包含 "test" 的用户</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteUsersByName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userMapper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="​高级用法"><a href="#​高级用法" class="headerlink" title="​高级用法"></a>​<strong>高级用法</strong></h4><p><strong>​（1）LambdaQueryWrapper（推荐）​</strong><br>避免字段名硬编码，使用实体类属性的 getter 方法：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserByLambda</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> lambdaQuery <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lambdaQuery<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token operator">::</span><span class="token function">getUsername</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>lambdaQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>（2）嵌套条件</strong></p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 查询 (age > 18 AND email 不为空) OR username = "admin"</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersWithNested</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span>wrapper <span class="token operator">-></span> wrapper<span class="token punctuation">.</span><span class="token function">gt</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isNotNull</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p> ​<strong>​（3）联表查询</strong><br>需配合自定义 SQL 和 <code>@TableField</code> 注解：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 1. 实体类中添加关联字段（假设需要关联部门表）</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// 非数据库字段</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> deptName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 2. Mapper 接口中定义方法</span><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"SELECT u.*, d.name AS dept_name FROM user u LEFT JOIN dept d ON u.dept_id = d.id $&#123;ew.customSqlSegment&#125;"</span><span class="token punctuation">)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">selectUserWithDept</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"ew"</span><span class="token punctuation">)</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3. 使用 QueryWrapper 添加条件</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> <span class="token function">getUsersWithDept</span><span class="token punctuation">(</span><span class="token class-name">String</span> deptName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"d.name"</span><span class="token punctuation">,</span> deptName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectUserWithDept</span><span class="token punctuation">(</span>queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="​总结"><a href="#​总结" class="headerlink" title="​总结"></a>​<strong>总结</strong></h4><table><thead><tr><th>​<strong>场景</strong></th><th>​<strong>方法示例</strong></th></tr></thead><tbody><tr><td>等值查询</td><td><code>.eq(&quot;字段名&quot;, 值)</code></td></tr><tr><td>模糊查询</td><td><code>.like(&quot;字段名&quot;, 值)</code></td></tr><tr><td>范围查询</td><td><code>.between(&quot;字段名&quot;, 最小值, 最大值)</code></td></tr><tr><td>排序</td><td><code>.orderByAsc(&quot;字段名&quot;)</code></td></tr><tr><td>分页</td><td><code>Page&lt;T&gt; + selectPage()</code></td></tr><tr><td>复杂条件组合</td><td><code>.and()</code>, <code>.or()</code></td></tr><tr><td>避免字段名硬编码</td><td>​<strong>使用 <code>LambdaQueryWrapper</code></strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目开发杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发杂记</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h4 id="Jupyter-Lab指定Conda环境作为Kernel"><a href="#Jupyter-Lab指定Conda环境作为Kernel" class="headerlink" title="Jupyter Lab指定Conda环境作为Kernel"></a>Jupyter Lab指定Conda环境作为Kernel</h4><ul><li><em><strong>问题</strong></em><br>本地安装好Anaconda后，可以在Anaconda Prompt里执行如下命令启动Jupyter Lab</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">jupyter lab</code></pre><p>我们在创建notebook的时候，可以选择kernel。</p><p>初始安装后，只有一个默认的kernel: Python 3，那我们怎么可以添加新的kernel呢？</p><p>方法是基于conda创建新的环境，然后把新的环境安装到Jupyter Lab的Kernel里，界面上就可以显示新的Kernel了。</p><ul><li><p><em><strong>操作步骤</strong></em></p></li><li><p>第一步，创建你需要的conda环境，假设名字为quant-dev。</p></li><li><p>第二步，激活你的环境quant-dev。</p>  <pre class="language-bash" data-language="bash"><code class="language-bash">conda activate quant-dev</code></pre></li><li><p>在这个conda环境里安装你需要的各种依赖包。<br>  使用conda install或者pip install都可以，都会把package安装在当前所处的quant-dev环境。</p>  <pre class="language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> package_xxxpip <span class="token function">install</span> package_xxx</code></pre></li><li><p>第三步，安装ipykernel。如果你的环境已经有了ipykernel那就可以跳过。使用conda install或者pip install安装都可以。</p>  <pre class="language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> ipykernelpip <span class="token function">install</span> ipykernel</code></pre></li><li><p>第四步，把conda环境写入jupyterlab的kernel中，用于Jupyter Lab界面显示。</p>  <pre class="language-bash" data-language="bash"><code class="language-bash">python <span class="token parameter variable">-m</span> ipykernel <span class="token function">install</span> <span class="token parameter variable">--name</span> quant-dev --display-name quant-dev</code></pre><ul><li><p>–name后面的参数是kernel的名字，执行<code>jupyter kernelspec list</code>会显示这里的名字。</p></li><li><p>–display-name后面的参数是Jupyter Lab界面显示的Kernel名字。</p></li><li><p>如果在上述命令增加–user则只给当前用户安装，而不是给系统里所有用户都安装。</p>  <pre class="language-bash" data-language="bash"><code class="language-bash">python <span class="token parameter variable">-m</span> ipykernel <span class="token function">install</span> <span class="token parameter variable">--user</span> <span class="token parameter variable">--name</span> quant-dev --display-name quant-dev</code></pre></li></ul></li><li><p>第五步，刷新Jupyter Lab页面，就可以展示新加的Kernel了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jupyter_notebook</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><ul><li>MyBatisX : 目前使用体验最好的SQL操作插件</li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>JetBrain全家桶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<ul><li>超好用git 入门教程: <a href="https://cloud.tencent.com/developer/article/1504684">https://cloud.tencent.com/developer/article/1504684</a></li></ul><h4 id="JetBrain系列IDE的git配置（本地项目上传github）"><a href="#JetBrain系列IDE的git配置（本地项目上传github）" class="headerlink" title="JetBrain系列IDE的git配置（本地项目上传github）"></a>JetBrain系列IDE的git配置（本地项目上传github）</h4><ul><li>最重要的一点：部分网络环境（例如校园网）会限制http形式443端口的连接，所以无法进行push&#x2F;pull相关操作，需要<em>使用SSH连接！！！</em></li><li>如果直接拉取项目内容，git clone即可，但是本地git仓库用IDE连接也不是很方便，还是直接用git建立连接，而不是用IDE（IDEA的share on github选项似乎默认使用https，连接会出现类似如下报错）<ul><li><em>Cannot load information for github.com&#x2F;VVX94:Request response: Access tothis site has been restricted.</em></li></ul></li><li>法一：<ul><li>github新建空白repository，复制对应SSH备用</li><li>本地选定项目文件夹，右键git bash here</li><li>输入<code>git clone git@github.com:yourName/yourProjectName.git</code></li><li>直接克隆空项目到本地，然后把项目内容移到clone的文件夹内</li><li>输入如下指令<ul><li><code>git add *</code> （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）</li><li><code>git commit  -m  &quot;提交信息&quot;</code>  （注：“提交信息”里面换成你需要，如“first commit”）</li><li><code>git push -u origin master</code>   （注：此操作目的是把本地仓库push到github上面）</li></ul></li></ul></li><li>法二：本地先创造一个git仓库，然后增加远程<ul><li>在项目内通过命令git init把这个文件夹变成Git可管理的仓库</li><li>通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）</li><li>git commit把项目提交到本地仓库</li><li>在github创建一个空仓库</li><li>Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地TEST仓库的命令行输入</li><li><code>git remote add origin git@github.com:yourName/yourProjectName.git</code></li><li>关联之后通过<code>git push -u origin master</code>推送到github</li><li>由于新建的远程仓库是空的，所以要加上<code>-u</code>这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了： <code>$ git push origin master</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 树状显示文件目录</span>tree 目标目录</code></pre>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jupyter notebook</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook 有两种键盘输入模式。</p><ul><li>编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。</li><li>命令模式，键盘输入运行程序命令；这时的单元框线是灰色。</li></ul><h2 id="命令模式-按键-Esc-开启"><a href="#命令模式-按键-Esc-开启" class="headerlink" title="命令模式 (按键 Esc 开启)"></a>命令模式 (按键 Esc 开启)</h2><ul><li><em>Enter : 转入编辑模式</em></li><li><em>Shift-Enter : 运行本单元，选中下个单元</em></li><li><em>Ctrl-Enter : 运行本单元</em></li><li><em>Alt-Enter : 运行本单元，在其下插入新单元</em></li><li><em>Y : 单元转入代码状态</em></li><li><em>M :单元转入markdown状态</em></li><li><em>R : 单元转入raw状态</em></li><li>1 : 设定 1 级标题</li><li>2 : 设定 2 级标题</li><li>3 : 设定 3 级标题</li><li>4 : 设定 4 级标题</li><li>5 : 设定 5 级标题</li><li>6 : 设定 6 级标题</li><li>Up : 选中上方单元</li><li><em>K : 选中上方单元</em></li><li>Down : 选中下方单元</li><li><em>J : 选中下方单元</em></li><li>Shift-K : 扩大选中上方单元</li><li>Shift-J : 扩大选中下方单元</li><li><em>A : 在上方插入新单元</em></li><li><em>B : 在下方插入新单元</em></li><li><em>X : 剪切选中的单元</em></li><li><em>C : 复制选中的单元</em></li><li>Shift-V : 粘贴到上方单元</li><li>V : 粘贴到下方单元</li><li>Z : 恢复删除的最后一个单元</li><li><em>D,D : 删除选中的单元</em></li><li>Shift-M : 合并选中的单元</li><li>Ctrl-S : 文件存盘</li><li>S : 文件存盘</li><li>L : 转换行号</li><li>O : 转换输出</li><li>Shift-O : 转换输出滚动</li><li>Esc : 关闭页面</li><li>Q : 关闭页面</li><li>H : 显示快捷键帮助</li><li><em>I,I : 中断Notebook内核</em></li><li><em>0,0 : 重启Notebook内核</em></li><li>Shift : 忽略</li><li>Shift-Space : 向上滚动</li><li>Space : 向下滚动</li></ul><h2 id="编辑模式-Enter-键启动"><a href="#编辑模式-Enter-键启动" class="headerlink" title="编辑模式 ( Enter 键启动)"></a>编辑模式 ( Enter 键启动)</h2><ul><li>Tab : 代码补全或缩进</li><li>Shift-Tab : 提示</li><li>Ctrl-] : 缩进</li><li>Ctrl-[ : 解除缩进</li><li>Ctrl-A : 全选</li><li>Ctrl-Z : 复原</li><li>Ctrl-Shift-Z : 再做</li><li>Ctrl-Y : 再做</li><li>Ctrl-Home : 跳到单元开头</li><li>Ctrl-Up : 跳到单元开头</li><li>Ctrl-End : 跳到单元末尾</li><li>Ctrl-Down : 跳到单元末尾</li><li>Ctrl-Left : 跳到左边一个字首</li><li>Ctrl-Right : 跳到右边一个字首</li><li>Ctrl-Backspace : 删除前面一个字</li><li>Ctrl-Delete : 删除后面一个字</li><li>Esc : 进入命令模式</li><li>Ctrl-M : 进入命令模式</li><li><em>Shift-Enter : 运行本单元，选中下一单元</em></li><li><em>Ctrl-Enter : 运行本单元</em></li><li><em>Alt-Enter : 运行本单元，在下面插入一单元</em></li><li>Ctrl-Shift– : 分割单元</li><li>Ctrl-Shift-Subtract : 分割单元</li><li>Ctrl-S : 文件存盘</li><li>Shift : 忽略</li><li>Up : 光标上移或转入上一单元</li><li>Down :光标下移或转入下一单元</li></ul>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>jupyter_notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="Arrays-copyofRange-arr-start-end"><a href="#Arrays-copyofRange-arr-start-end" class="headerlink" title="Arrays.copyofRange(arr,start,end);"></a><code>Arrays.copyofRange(arr,start,end);</code></h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//create a new array by copying a specified range of elements from an existing array. It provides a way to copy a subset of elements between two indices by creating a new array of the same type</span><span class="token comment">//左闭右开区间</span><span class="token comment">//e.g.</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Original array</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token comment">// Copy elements from index 1 to 3 (exclusive)</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Copied Array: "</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//result: [20,30]</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="查询-conda-版本"><a href="#查询-conda-版本" class="headerlink" title="查询 conda 版本"></a>查询 conda 版本</h3><blockquote><p>conda –version</p></blockquote><h3 id="更新-conda"><a href="#更新-conda" class="headerlink" title="更新 conda"></a>更新 conda</h3><blockquote><p>conda update conda</p></blockquote><h3 id="查看conda环境详细信息"><a href="#查看conda环境详细信息" class="headerlink" title="查看conda环境详细信息"></a>查看conda环境详细信息</h3><blockquote><p>conda info</p></blockquote><h2 id="虚拟环境管理"><a href="#虚拟环境管理" class="headerlink" title="虚拟环境管理"></a>虚拟环境管理</h2><h3 id="查看当前有哪些虚拟环境"><a href="#查看当前有哪些虚拟环境" class="headerlink" title="查看当前有哪些虚拟环境"></a>查看当前有哪些虚拟环境</h3><blockquote><p>conda env list</p></blockquote><p>或者使用如下命令：</p><blockquote><p>conda info –envs</p></blockquote><h3 id="创建一个新的虚拟环境"><a href="#创建一个新的虚拟环境" class="headerlink" title="创建一个新的虚拟环境"></a>创建一个新的虚拟环境</h3><blockquote><p>conda create –name jupyter_venv python&#x3D;3.8</p></blockquote><p>其中，通过 <code>-n</code>或<code>--name</code> 来自定义的环境名称，如：<code>jupyter_venv</code>；同时，指定Python的版本。</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><blockquote><p>conda activate jupyter_venv</p></blockquote><h3 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h3><blockquote><p>conda deactivate</p></blockquote><h3 id="删除某个虚拟环境"><a href="#删除某个虚拟环境" class="headerlink" title="删除某个虚拟环境"></a>删除某个虚拟环境</h3><blockquote><p>conda remove -n your_env_name –all 其中，<code>-n</code>与<code>--name</code>等价，表示虚拟环境名</p></blockquote><h3 id="复制某个虚拟环境"><a href="#复制某个虚拟环境" class="headerlink" title="复制某个虚拟环境"></a>复制某个虚拟环境</h3><blockquote><p>conda create –name new_env_name –clone old_env_name</p></blockquote><h3 id="分享-备份一个虚拟环境"><a href="#分享-备份一个虚拟环境" class="headerlink" title="分享&#x2F;备份一个虚拟环境"></a>分享&#x2F;备份一个虚拟环境</h3><p>一个分享环境的快速方法就是给他一个你的环境的<code>.yml</code>文件。</p><p>首先激活要分享的环境，在当前工作目录下生成一个<code>environment.yml</code>文件。</p><blockquote><p>conda env export &gt; environment.yml</p></blockquote><p>对方拿到<code>environment.yml</code>文件后，将该文件放在工作目录下，可以通过以下命令从该文件创建环境即可。</p><blockquote><p>conda env create -f environment.yml</p></blockquote><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><blockquote><p>conda install [package] (如：<code>conda install numpy</code>)</p></blockquote><p>指定包版本：</p><blockquote><p>conda install xlrd&#x3D;1.2.0 (注意是单等于号）</p></blockquote><p>也可以使用<code>pip install</code>安装：</p><blockquote><p>pip install xlrd==1.2.0 (注意是双等于号）</p></blockquote><h1 id="批量安装-requirements-txt-文件中包含的组件依赖"><a href="#批量安装-requirements-txt-文件中包含的组件依赖" class="headerlink" title="批量安装 requirements.txt 文件中包含的组件依赖"></a>批量安装 requirements.txt 文件中包含的组件依赖</h1><p>conda install –yes –file requirements.txt<br>复制代码</p><h3 id="批量导出依赖包"><a href="#批量导出依赖包" class="headerlink" title="批量导出依赖包"></a>批量导出依赖包</h3><p>批量导出包含环境中所有依赖包到requirements.txt文件。</p><p>conda list -e &gt; requirements.txt<br>复制代码</p><h3 id="删除当前环境中的某个包"><a href="#删除当前环境中的某个包" class="headerlink" title="删除当前环境中的某个包"></a>删除当前环境中的某个包</h3><blockquote><p>conda remove [package]</p></blockquote><p>注意：这里并非<code>conda uninstall</code>，只有在<code>pip</code>指令下才有<code>pip uninstal</code>。</p><h3 id="升级当前环境中的某个包"><a href="#升级当前环境中的某个包" class="headerlink" title="升级当前环境中的某个包"></a>升级当前环境中的某个包</h3><blockquote><p>conda update [package]</p></blockquote><p>升级所有包：</p><blockquote><p>conda update –all</p></blockquote><h3 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h3><blockquote><p>conda search [package]</p></blockquote><h3 id="删除没有用的安装包"><a href="#删除没有用的安装包" class="headerlink" title="删除没有用的安装包"></a>删除没有用的安装包</h3><p>Conda 安装的包都在目录<code>Anaconda/pkgs</code>下。随着使用，conda 安装的包也越来越多；有时候会出现以下不好的情况：</p><ul><li>有些包安装之后，从来没有使用过；</li><li>一些安装包的tar包也保留在了计算机中；</li><li>由于依赖或者环境等原因，某些包的不同版本重复安装。</li></ul><p>上面的这些情况使得anaconda显得更加冗余，并且浪费储存；对于这些情况可以使用<code>conda clean</code> 净化Anaconda。</p><blockquote><p>conda clean -p</p></blockquote><p>或者</p><blockquote><p>conda clean –packages</p></blockquote><h3 id="删除tar包"><a href="#删除tar包" class="headerlink" title="删除tar包"></a>删除tar包</h3><blockquote><p>conda clean -t</p></blockquote><p>或者</p><blockquote><p>conda clean –tarballs</p></blockquote><h3 id="删除所有的安装包及cache"><a href="#删除所有的安装包及cache" class="headerlink" title="删除所有的安装包及cache"></a>删除所有的安装包及cache</h3><p>删除索引缓存、锁定文件、未使用过的包和tar包。</p><blockquote><p>conda clean -y –all</p></blockquote><h2 id="镜像源管理"><a href="#镜像源管理" class="headerlink" title="镜像源管理"></a>镜像源管理</h2><h3 id="查看镜像源"><a href="#查看镜像源" class="headerlink" title="查看镜像源"></a>查看镜像源</h3><blockquote><p>conda config –show channels</p></blockquote><h3 id="添加镜像源"><a href="#添加镜像源" class="headerlink" title="添加镜像源"></a>添加镜像源</h3><p>如：添加清华源</p><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>复制代码</p><h3 id="配置安装包时显示安装来源"><a href="#配置安装包时显示安装来源" class="headerlink" title="配置安装包时显示安装来源"></a>配置安装包时显示安装来源</h3><blockquote><p>conda config –set show_channel_urls yes</p></blockquote><p>上面的设置表示从channel中安装包时显示channel的url，这样就可以知道包的安装来源了。</p><h3 id="清除索引缓存，保证用的是镜像站提供的索引"><a href="#清除索引缓存，保证用的是镜像站提供的索引" class="headerlink" title="清除索引缓存，保证用的是镜像站提供的索引"></a>清除索引缓存，保证用的是镜像站提供的索引</h3><blockquote><p>conda clean -i</p></blockquote><h3 id="切换回默认源"><a href="#切换回默认源" class="headerlink" title="切换回默认源"></a>切换回默认源</h3><blockquote><p>conda config –remove-key channels</p></blockquote><h3 id="移除某个镜像源"><a href="#移除某个镜像源" class="headerlink" title="移除某个镜像源"></a>移除某个镜像源</h3><p>如：移除清华源</p><pre class="language-bash" data-language="bash"><code class="language-bash">conda config <span class="token parameter variable">--remove</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</code></pre><h3 id="临时指定安装某个包使用的镜像源"><a href="#临时指定安装某个包使用的镜像源" class="headerlink" title="临时指定安装某个包使用的镜像源"></a>临时指定安装某个包使用的镜像源</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> <span class="token punctuation">[</span>package<span class="token punctuation">]</span> <span class="token parameter variable">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple/pip <span class="token function">install</span> <span class="token punctuation">[</span>package<span class="token punctuation">]</span> <span class="token parameter variable">-i</span> http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></pre>]]></content>
    
    
    <categories>
      
      <category>常用语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用语法</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.MySQL</title>
    <link href="/posts/undefined.html"/>
    <url>/posts/undefined.html</url>
    
    <content type="html"><![CDATA[<h4 id="MySQL-的存储引擎有哪些？它们之间有什么区别？"><a href="#MySQL-的存储引擎有哪些？它们之间有什么区别？" class="headerlink" title="MySQL 的存储引擎有哪些？它们之间有什么区别？"></a>MySQL 的存储引擎有哪些？它们之间有什么区别？</h4><ul><li>MySql共有10个不同的存储引擎，其中最主要的为<em>InnoDB和MyISAM</em>，其他还有<em>Memory, NDB, ARCHIVE</em>, CSV, Blackhole, Merge, Federated, Example</li><li><em><strong>InnoDB</strong></em><ul><li>支持<em>事务、行级锁和外键</em>。</li><li>提供<em>高并发性能</em>，适用于高负载的 OLTP 应用。</li><li>数据以<em>聚集索引</em>的方式存储，提高检索效率</li></ul></li><li><em><strong>MyISAM</strong></em><ul><li><em>不支持事务和外键</em>，使用表级锁。</li><li>适合<em>读取多、更新少</em>的场景，如数据仓库。</li><li>具有较高的读性能和较快的表级锁定。</li></ul></li><li><em><strong>MEMORY</strong></em><ul><li>数据存储在内存中，速度快，但数据在服务器重启后丢失。</li><li>适用于临时数据存储或快速缓存。</li></ul></li><li><em><strong>NDB (NDBCluster)：</strong></em><ul><li>支持高可用性和数据分布，适合大规模分布式应用</li><li>提供行级锁和自动分区。</li></ul></li><li><em><strong>ARCHIVE</strong></em>：<ul><li>用于存储大量历史数据，支持高效的插入和压缩。</li><li>不支持索引，适合日志数据存储。</li></ul></li><li></li></ul><h4 id="InnoDB学习记录"><a href="#InnoDB学习记录" class="headerlink" title="InnoDB学习记录"></a>InnoDB学习记录</h4><ul><li><p>昨晚看了两三个多小时，依旧没把这题看完，险些道心破碎，结果今天一看，嘿，原来直接搞定了一堆题目，爽了。</p></li><li><p><em><strong>InnoDB（详细可见 <a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-introduction.html">官方文档</a>）</strong></em></p><ul><li>一个兼顾高可靠性和高性能的通用存储引擎。在 MySQL 8.4 中，<code>InnoDB</code> 是默认的 MySQL 存储引擎。</li><li>主要优势：<ul><li>DML操作遵循 ACID 模型，事务具有<em>提交、回滚和崩溃恢复</em>功能，以保护用户数据</li><li><em>行级锁和 Oracle 风格的一致性读取</em>可以提高多用户并发和性能</li><li><em>聚簇索引</em>的方式可最大限度减少逐渐查找的I&#x2F;O</li><li>为了保持数据完整性，<code>InnoDB</code> 支持 <code>FOREIGN KEY</code> 约束</li></ul></li><li>数据存储结构<ul><li><em>表空间</em>：数据存储在表空间文件（<code>.ibd</code>）中，包含 <strong>数据段</strong>（存储行数据）、<strong>索引段</strong>（存储索引）和 <strong>回滚段</strong>（存储事务回滚信息）。</li><li>页：数据以固定大小的 <strong>页（16KB）</strong> 为单位存储，每个页包含行数据，页目录，页头，文件头</li></ul></li><li><em>功能</em>：<ul><li><img src="/img/Pasted_image_20250311110109.png"></li><li>基于文档中的表格，可以发现支持的索引方式有以下几种：<ul><li>B+树索引（聚簇索引）<ul><li>注意：支持聚簇索引，但是不支持聚簇数据库（cluster database support）</li></ul></li><li>全文搜索索引（也即倒排索引）</li><li>哈希索引</li><li>R-tree索引</li><li>不支持T-tree索引</li></ul></li></ul></li><li><em><strong>几个提及的相关概念在下面做详细解释</strong></em></li></ul></li><li><p><em><strong>B树和B+树</strong></em></p><ul><li>在了解<em><strong>B树</strong></em>之前，想必大家已经了解过AVL树和红黑树等，这些二叉树虽然已经能实现<code>O(logn)</code>级别的增删改查复杂度，但是我们也需要意识到，同为<code>O(logn)</code>亦有区别。</li><li>让我们看看两种数据结构的图示：<ul><li><img src="/img/Pasted_image_20250311111828.png"></li></ul></li><li>在查询时，需要先从硬盘中读取数据再做后续操作，假设需要查询有序二叉树中的F，需要查询3次才能找到对应节点，也即3次I&#x2F;O操作，<em>这种I&#x2F;O操作非常耗时，且与树的高度正相关</em>，相比而言内存中数据处理耗费的时间可以忽略不计。</li><li>那么，怎么才能减少I&#x2F;O操作呢？一种直观且自然的想法就是压缩树的高度。这就是B树的基本目标：<em>为磁盘存储优化，通过降低树的高度减少磁盘访问次数，支持随机读写</em></li><li><strong>那么B树的节点结构是怎么设计的</strong>？<ul><li>首先，每个节点最多包含m个子节点，有m-1个分支，被称为m阶B树，阶数通常由磁盘块的大小决定，例如每个节点存储一个磁盘块</li><li>非叶子节点存储键和指针，同时<em>直接存储数据</em>（注意，与B+树的一个主要区别）</li><li>所有叶子位于同一层，以此确保树的平衡性</li><li>在设计上，内部节点至少有$\lceil \frac{m}{2} \rceil$个子节点</li></ul></li><li><strong>核心操作</strong>：<ul><li>查找：从根节点开始逐层比较，找到目标数据所在子树，最后在叶子节点或内部节点找到数据</li><li>插入：在叶子节点插入，可能导致节点分裂（节点键数超过<code>n-1</code>），会在$\lceil \frac{m}{2} \rceil$处分裂，分裂后的中间键提升到父节点，如果父节点键数超过m-1，会继续向上分裂</li><li>删除：<ul><li>如果是内部节点，会用叶子节点取代内部节点的位置，从而转化为叶子节点的删除</li><li>如果删除叶子节点，当节点键数小于$\lceil \frac{m}{2} \rceil-1$，会需要借键或与兄弟节点合并</li></ul></li></ul></li><li><em><strong>B+树</strong></em><ul><li>在B树基础上进一步<em>优化了顺序访问和范围查询</em>，尤其适合<em><strong>数据库索引</strong></em></li><li>节点结构（<em>注意与B树的不同</em>）<ul><li><strong>内部节点仅存储键和指针</strong>，<strong>不存储实际数据</strong>。</li><li><strong>所有数据存储在叶子节点</strong>，叶子节点通过<em>指针</em>形成<em>双向链表，支持高效顺序扫描</em>。</li><li>叶子节点包含所有键的副本，且键值按顺序排列。</li><li>阶数类似于B树，但是数据仅存在于叶子节点</li></ul></li><li><img src="/img/Pasted_image_20250311144321.png"></li><li><strong>优点</strong><ul><li><strong>范围查询高效</strong>：叶子节点的链表结构支持线性遍历</li><li><strong>更高的扇出（Fan-out）</strong>：内部节点不存数据，可容纳更多键，树更矮，I&#x2F;O更少</li><li><strong>查询稳定性</strong>：所有查询均需访问到叶子节点，路径长度一致</li></ul></li></ul></li></ul></li><li><p><em><strong>聚簇索引和非聚簇索引</strong></em></p><ul><li>先放上聚簇索引和非聚簇索引的示意图（源自B站up<a href="https://www.bilibili.com/video/BV17D4y1e78A">猿人林克</a>）</li><li><img src="/img/Pasted_image_20250311145818.png"></li><li><img src="/img/Pasted_image_20250311150056.png"></li><li><img src="/img/Pasted_image_20250311150426.png"></li><li><strong>聚簇索引</strong>在叶子节点中记录的是每行的真实数据，非叶子节点中记录的是每行的key<ul><li>数据行的物理顺序与索引键值的逻辑顺序一致。</li><li>每个表<strong>只能有一个聚簇索引</strong>（因为数据只能按一种物理顺序存储）。</li><li>在多数数据库（如MySQL InnoDB）中，<strong>主键默认是聚簇索引</strong>。若未定义主键，则选择第一个<em>唯一非空索引（UNIQUE）</em> 替代；若无，隐式生成一个<em>隐藏的聚簇索引</em>。</li><li>优点：<ul><li><strong>范围查询高效</strong>：数据物理连续，减少磁盘I&#x2F;O</li><li><strong>排序和分组优化</strong>：若查询的 <code>ORDER BY</code> 或 <code>GROUP BY</code> 列是聚簇索引键，无需额外排序。</li><li><strong>覆盖索引优势</strong>：  若查询仅需聚簇索引列，无需回表。</li></ul></li><li>缺点<ul><li><strong>插入&#x2F;更新开销大</strong>：  插入数据到非末尾位置可能导致<strong>页分裂</strong>（Page Split），产生碎片，降低性能。</li><li><strong>维护成本高</strong>：  频繁更新的列不适合作为聚簇索引键。</li></ul></li><li>适用场景：<ul><li>主键或频繁用于范围查询的列</li><li>需要频繁排序或分组的列。</li></ul></li></ul></li><li><strong>非聚簇索引</strong>(Secondary Indexes)又被称为二级索引，除了聚簇索引外的每一个索引都会构成一个非聚簇索引树，叶子节点记录的是每行数据在聚簇索引中的key,<ul><li>数据行的物理顺序与索引键值无关。</li><li>每个表可创建<strong>多个非聚簇索引</strong>（如为不同查询条件优化）。</li><li><strong>回表（Bookmark Lookup）</strong>：  通过索引找到键值后，需根据<em>指针回表</em>查询完整数据行。（也即图中显示的到聚簇索引中查找，<em>首先通过索引定位到对应页，然后再根据行的物理地址找到所需的数据行</em>）</li><li>优点：<ul><li><strong>插入&#x2F;更新开销低</strong>：  不改变数据物理顺序，维护成本低于聚簇索引。</li><li><strong>多维度优化</strong>：  可为不同查询条件创建多个索引。</li></ul></li><li>缺点：<ul><li><strong>查询效率依赖回表</strong>：若查询字段未完全包含在索引中，需额外I&#x2F;O访问数据页。</li><li><strong>空间占用</strong>：多个索引会占用更多存储空间。</li></ul></li><li><strong>适用场景</strong><ul><li>高频查询的 <code>WHERE</code> 条件列（如用户名、商品类别）。</li><li>需要避免全表扫描的查询列。</li></ul></li></ul></li></ul></li><li><p>R-tree索引和T-tree索引</p><ul><li><strong>T-tree(事务树)</strong><ul><li>是一种专为<em>内存数据库</em>设计的高效索引结构，如如 Oracle TimesTen、SAP HANA等，结合了 <strong>AVL树</strong>（平衡二叉搜索树）和 <strong>B树</strong> 的特点。</li><li><strong>节点结构</strong>：<ul><li>每个节点包含 <strong>多个键值对</strong>（类似B树），但节点容量较小（通常为几十个键）。</li><li>每个节点维护一个 <strong>有序键值范围</strong>，并记录子节点的最小&#x2F;最大值。</li></ul></li><li><strong>优点</strong><ul><li>内存优化：减少指针数量，提高缓存利用率。</li><li>适合频繁更新的内存数据库（如实时交易系统）</li></ul></li></ul></li><li><strong>R-tree(空间索引树)</strong><ul><li>专为多维数据（如地理坐标、图形）设计的空间索引结构，支持高效范围查询</li><li><strong>节点结构</strong>：<ul><li>每个节点代表一个 <strong>最小边界矩形（MBR, Minimum Bounding Rectangle）</strong>，涵盖其子节点或数据对象的所有空间范围。</li><li>叶子节点存储实际数据对象的空间范围，非叶子节点存储子节点的MBR。</li></ul></li></ul></li></ul></li><li><p><em><strong>回到本题，继续学习InnoDB和MyISAM的区别</strong></em></p><ul><li><strong>InnoDB</strong>：现代数据库的标配，以 <strong>事务安全</strong> 和 <strong>高并发</strong> 为核心优势。</li><li><strong>MyISAM</strong>：仅适用于 <strong>读多写少</strong> 且 <strong>无需事务</strong> 的遗留场景。</li><li>事务与锁：<ul><li>InnoDB:<ul><li>支持事务的提交（COMMIT）和回滚（ROLLBACK），保证数据一致性。</li><li>默认使用 <strong>行级锁</strong>（通过索引实现），支持高并发写入。</li><li>通过 <strong>MVCC</strong>（多版本并发控制）实现非阻塞读（<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别）。</li></ul></li><li>MyISAM:<ul><li><strong>表级锁</strong>：任何写操作会锁住整个表，导致并发性能急剧下降。</li><li>高并发场景下，<code>INSERT</code> 和 <code>SELECT</code> 可能互相阻塞。</li></ul></li></ul></li><li>索引与数据存储<ul><li><strong>InnoDB</strong>：<ul><li><strong>聚簇索引</strong>：数据按主键顺序物理存储，二级索引存储主键值（需回表查询）。</li><li>建议使用 <strong>自增整数</strong>（避免页分裂）</li></ul></li><li><strong>MyISAM</strong>：<ul><li><strong>非聚簇索引</strong>：数据与索引分离，所有索引均存储数据行的物理地址（如偏移量）。</li><li>主键与普通索引无本质区别，查询时需两次寻址（索引→数据文件）</li></ul></li></ul></li><li><strong>性能与适用场景</strong><ul><li><strong>InnoDB 优势场景</strong>：<ul><li><strong>OLTP（联机事务处理）</strong>：如电商订单、支付系统，需高并发写入和事务安全。</li><li><strong>数据一致性要求高</strong>：如银行转账、库存扣减，依赖事务回滚和锁机制。</li><li><strong>大数据量范围查询</strong>：聚簇索引优化范围扫描（如 <code>WHERE date BETWEEN ...</code>）。</li></ul></li><li><strong>MyISAM 优势场景</strong>：<ul><li><strong>OLAP（联机分析处理）</strong>：如日志分析、报表统计，读多写少且无需事务。</li><li><strong>全文搜索（旧版本 MySQL）</strong>：MyISAM 早期版本全文索引性能更优（MySQL 5.6+ InnoDB 已支持）。</li><li><strong>只读或低频写入表</strong>：如静态配置表、归档数据表。</li></ul></li></ul></li><li><strong>崩溃恢复以及数据安全</strong><ul><li><strong>InnoDB</strong>：<ul><li>通过 <strong>Redo Log（重做日志）</strong> 和 <strong>Undo Log（回滚日志）</strong> 保证崩溃后数据一致。</li><li>支持 <strong>Double Write Buffer</strong> 防止部分写（Partial Write）导致数据损坏。</li></ul></li><li><strong>MyISAM</strong>：<ul><li>无事务日志，崩溃后需手动执行 <code>CHECK TABLE</code> 和 <code>REPAIR TABLE</code>。</li><li>数据损坏风险更高（如服务器意外断电可能导致表不可用）。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>事务支持</strong></td><td>✅ 支持 ACID 事务</td><td>❌ 不支持事务</td></tr><tr><td><strong>锁粒度</strong></td><td>行级锁（默认）</td><td>表级锁</td></tr><tr><td><strong>外键约束</strong></td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td><strong>崩溃恢复能力</strong></td><td>✅ 支持崩溃后自动恢复（Redo Log）</td><td>❌ 需手动修复（<code>REPAIR TABLE</code>）</td></tr><tr><td><strong>索引类型</strong></td><td>聚簇索引（数据与主键绑定）</td><td>非聚簇索引（数据与索引分离）</td></tr><tr><td><strong>MVCC（多版本并发控制）</strong></td><td>✅ 支持（通过 Undo Log 实现）</td><td>❌ 不支持</td></tr><tr><td><strong>全文索引</strong></td><td>✅ MySQL 5.6+ 支持</td><td>✅ 原生支持（较早版本）</td></tr><tr><td><strong>缓存机制</strong></td><td>缓存数据和索引（缓冲池）</td><td>仅缓存索引（Key Buffer）</td></tr><tr><td><strong>存储文件结构</strong></td><td><code>.ibd</code>（数据+索引）或共享表空间（<code>ibdata</code>）</td><td><code>.MYD</code>（数据）、<code>.MYI</code>（索引）、<code>.frm</code>（表结构）</td></tr><tr><td><strong>COUNT(*) 优化</strong></td><td>需全表扫描或统计近似值</td><td>✅ 直接返回缓存的行数（无需扫描）</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="949-MySQL-三层-B-树能存多少数据？"><a href="#949-MySQL-三层-B-树能存多少数据？" class="headerlink" title="949. MySQL 三层 B+ 树能存多少数据？"></a>949. MySQL 三层 B+ 树能存多少数据？</h4><ul><li>假设参数：<ul><li>页大小（Page Size）：在 MySQL 的 InnoDB 存储引擎中，默认的页大小是 16KB（16 * 1024 &#x3D; 16384 字节）。</li><li>键值大小（Key Size）：假设索引键值为 BIGINT 类型，占用 8 字节。</li><li>指针大小（Pointer Size）：用于指向子节点或数据记录的指针，通常占用 6 字节。</li><li>记录大小（Record Size）：假设每条数据记录占用 1024 字节（1KB）。</li></ul></li><li>对于叶子节点：存储数据，可以存储$16KB \div 1KB &#x3D; 16$条</li><li>对于第二层：一个索引占据$8+6&#x3D;14byte$ 则一页可以存储$16KB \div 14byte &#x3D; (16 \times 1024) byte \div 14byte &#x3D; 1170$</li><li>对于根节点：可以存储1170个索引</li><li>综合：$1170 \times 1170 \times 16 &#x3D; 21902400$</li><li>这也说明，当数据量超过2000万条时，需要进行分表操作</li></ul><h4 id="594-MySQL-索引的最左前缀匹配原则是什么？"><a href="#594-MySQL-索引的最左前缀匹配原则是什么？" class="headerlink" title="594. MySQL 索引的最左前缀匹配原则是什么？"></a>594. MySQL 索引的最左前缀匹配原则是什么？</h4><p>MySQL 的 <strong>最左前缀匹配原则（Leftmost Prefix Principle）</strong> 是联合索引（Composite Index）的核心使用规则，直接影响索引是否生效及查询效率。以下从 <strong>原理、示例、场景优化</strong> 三个维度详细解析：</p><hr><p><em><strong>一、原理详解</strong></em></p><ol><li><strong>联合索引的结构</strong><ul><li>假设创建联合索引 <code>INDEX idx_a_b_c (a, b, c)</code>，索引在磁盘中的存储逻辑如下：<ul><li><strong>按列顺序排序</strong>：先按 <code>a</code> 排序 → <code>a</code> 相同再按 <code>b</code> 排序 → <code>a</code> 和 <code>b</code> 都相同最后按 <code>c</code> 排序。</li><li><strong>类似电话簿</strong>：先按姓氏排序，再按名字排序，最后按城市排序。</li></ul></li></ul></li><li><strong>最左前缀规则</strong><br>查询时，<strong>必须从索引的最左列开始</strong>，且<strong>不能跳过中间的列</strong>。以下情况索引可能生效：<br>- 使用 <code>a</code> 列 → ✅<br>- 使用 <code>a + b</code> → ✅<br>- 使用 <code>a + b + c</code> → ✅<br>- 使用 <code>a + c</code> → ⚠️ <strong>部分生效</strong>（仅 <code>a</code> 生效，<code>c</code> 不生效）<br>- 使用 <code>b</code> 或 <code>c</code> 或 <code>b + c</code> → ❌ 不生效</li><li><strong>底层原因</strong><ul><li><strong>索引有序性</strong>：索引按 <code>(a, b, c)</code> 的顺序构建，跳过左列会导致后续列无序，无法利用二分查找。</li><li><strong>B+树结构</strong>：非最左列的查询需遍历整个索引树，效率可能不如全表扫描。</li></ul></li></ol><hr><p>二、示例分析</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">#  示例表结构CREATE TABLE users (    id INT PRIMARY KEY,    country VARCHAR(50),    city VARCHAR(50),    age INT,    INDEX idx_country_city_age (country, city, age));</code></pre><ol><li><p><strong>生效的查询场景</strong></p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ✅ 使用最左列 country</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span><span class="token punctuation">;</span><span class="token comment">-- ✅ 使用 country + city</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span><span class="token punctuation">;</span><span class="token comment">-- ✅ 使用 country + city + age（全列匹配）</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span> <span class="token operator">AND</span> age <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>部分生效的场景</strong></p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ⚠️ 仅 country 生效，age 无法走索引（中间跳过了 city）</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">-- ⚠️ 范围查询后，后续列无法走索引（city='Beijing' 生效，但 age 不生效）</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">></span> <span class="token string">'A'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">-- 仅 country + city 生效</span></code></pre></li><li><p><strong>不生效的场景</strong></p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ❌ 未使用最左列 country</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span><span class="token punctuation">;</span><span class="token comment">-- ❌ 跳过了中间列 city</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>如果遇到范围查询(&gt;、&lt;)，就会停止匹配</strong>。</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&gt;1, b&#x3D;2, c&#x3D;3;</code></pre></li></ol><ul><li><p>所谓的停止匹配指的是：a 可以用上联合索引，但是 b 和 c 却不行。因为 a 需要先经过范围查询，此时经过筛选得到 b 和 c 的数据是无序的。比如 a 为 1 和 a 为 2 数据之间 b 和 c 是无序的，因此无法利用索引查询。</p></li><li><p><strong>如果遇到如 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、前缀like（xx%）的范围查询，则不会停止匹配</strong>。因为这些查询包含一个等值判断，可以直接定位到某个数据，然后往后扫描即可。</p></li></ul><p>例如：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&gt;&#x3D;1, b&#x3D;2, c&#x3D;3;</code></pre><ul><li><p>查询可以定位到 a&#x3D;1 这条数据，然后往后遍历即可，而定<strong>位到的 a&#x3D;1 数据内，b 和 c 是有序的，因此可以利用索引查询</strong>。</p></li><li><p>而以下的查询则可以全部用上联合索引：</p><pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&#x3D;1, b&#x3D;2, c&gt;3;</code></pre></li><li><p>因为 a 和 b 是等值查询的情况下，c 是有序的，有序就可以用上索引。</p></li></ul><hr><p>三、场景优化策略</p><ol><li><strong>合理设计联合索引顺序</strong></li></ol><ul><li><strong>高频查询条件在前</strong>：将最常用的列放在索引左侧。</li></ul><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 假设查询条件多为 country + city，而非单独 country</span><span class="token keyword">INDEX</span> idx_country_city <span class="token punctuation">(</span>country<span class="token punctuation">,</span> city<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong>区分度高的列在前</strong>：区分度高的列（唯一值多）能更快缩小查询范围。  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- country 有 100 个值，city 有 1000 个值 → 优先 city 在前？</span><span class="token comment">-- 错误！必须结合查询条件频率，不能只看区分度。</span></code></pre></li></ul><ol start="2"><li><strong>处理范围查询</strong></li></ol><ul><li><strong>范围查询后的列无法走索引</strong>：  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">></span> <span class="token string">'Beijing'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span><span class="token comment">-- 实际生效索引：country + city（age 无法利用索引）</span></code></pre></li><li><strong>优化方案</strong>：将等值查询列放在范围查询列之前。<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果查询条件多为 country + age，且 age 是范围查询：</span><span class="token comment">-- 需要重新设计索引，但受最左前缀限制，可能需要单独创建 (country, age) 索引。</span></code></pre></li></ul><ol start="3"><li><strong>覆盖索引优化</strong></li></ol><ul><li><strong>无需回表</strong>：若查询字段全部在索引中，即使跳过中间列，也可能触发覆盖索引。<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span><span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> city<span class="token punctuation">,</span> age <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">-- ⚠️ 使用覆盖索引（Extra: Using index）</span></code></pre></li></ul><ol start="4"><li><strong>索引下推（Index Condition Pushdown, ICP）</strong></li></ol><ul><li><strong>MySQL 5.6+ 特性</strong>：将 <code>WHERE</code> 条件中索引列的过滤下推到存储引擎层。  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">LIKE</span> <span class="token string">'B%'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span><span class="token comment">-- 即使 city 是模糊查询，ICP 会在引擎层过滤 age=25 的记录，减少回表次数。</span></code></pre></li></ul><h4 id="593-MySQL中的回表是什么"><a href="#593-MySQL中的回表是什么" class="headerlink" title="593.MySQL中的回表是什么"></a>593.MySQL中的回表是什么</h4><ul><li>“回表” 是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，<strong>这个过程被称为回表</strong>。</li><li>回表其实不仅仅只是多查一次，<strong>还会带来随机 I&#x2F;O</strong>。</li><li>因为通过 id 去主键索引查询的时候，id 肯定是不连续的（例如 age 为 20 的人很多，age 索引中年龄是有序的，但是 id 无序，且是不连续的），所以去主键索引频繁查询会造成大量随机 I&#x2F;O ，我们都知道顺序 I&#x2F;O 查询快，而随机 I&#x2F;O 慢，所以频繁回表效率很低。</li><li>因此，不要因为图方便，在代码里都用 select * ，从而引发不必要的回表操作。</li><li><em><strong>覆盖索引</strong></em><ul><li>指<strong>查询的列完全包含在某个索引中</strong>，数据库可以直接通过索引返回结果，无需回表（即无需访问数据行）。这种优化可显著减少磁盘 I&#x2F;O，提升查询性能。</li><li>假设有一个联合索引<code>INDEX idx_age_city (age, city)</code>,</li><li><img src="/img/Pasted%20image%2020250312132622.png"></li></ul></li><li><em><strong>索引下推(Index Condition Pushdown，简称 ICP)</strong></em><ul><li>MySQL的大概架构：<ul><li><img src="/img/Pasted%20image%2020250312132750.png"></li></ul></li><li><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</li><li><strong>注意：索引下推是应用在<em>联合索引</em>上的。</strong></li><li>对<em>InnoDB和MYISAM</em>两个存储引擎都生效</li><li>我们来具体看一下，在<em>没有使用ICP</em>的情况下，MySQL的查询：<ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul></li><li><em>使用ICP</em>的情况下，查询过程：<ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li></ul></li><li><em><strong>Using index</strong></em>：表示查询可以完全通过索引来获取数据，不需要访问数据表的行（即 “索引覆盖”）。这种情况性能较好，因为只访问了索引，没有读表。</li><li><em><strong>Using index condition</strong></em>：表示 MySQL 只使用了索引进行部分过滤，但仍然需要读取表中的数据行。虽然通过索引进行了一定的优化，但相比完全使用索引，性能会略逊一筹。</li></ul></li></ul><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐操作</strong></th></tr></thead><tbody><tr><td>高频等值查询</td><td>建 B-Tree 索引，优先选择高选择性列。</td></tr><tr><td>范围查询 + 排序</td><td>复合索引按等值列在前、范围列在后。</td></tr><tr><td>避免回表</td><td>使用覆盖索引。</td></tr><tr><td>长字符串列</td><td>使用前缀索引。</td></tr><tr><td>数据频繁更新</td><td>减少索引数量，避免在频繁修改的列上建索引。</td></tr></tbody></table><ol><li><p><strong>只为高频查询列建索引</strong></p><ul><li>索引会占用存储空间，且增删改操作需维护索引，<strong>避免过度索引</strong>。</li><li>优先为高频查询的 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 涉及的列建索引。</li></ul></li><li><p><strong>选择合适索引类型</strong></p><ul><li><strong>B-Tree 索引</strong>：默认类型，支持范围查询（<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>）、排序和前缀匹配。</li><li><strong>哈希索引</strong>：仅支持等值查询（<code>=</code>），适用于内存表（Memory Engine）。</li><li><strong>全文索引</strong>：用于文本字段的全文搜索（<code>MATCH ... AGAINST</code>）。</li><li><strong>空间索引</strong>：用于地理数据（如 <code>GEOMETRY</code> 类型）。</li></ul></li><li><p><strong>利用最左前缀原则</strong></p><ul><li>复合索引 <code>(a, b, c)</code> 生效的场景：<ul><li><code>WHERE a=1</code></li><li><code>WHERE a=1 AND b=2</code></li><li><code>WHERE a=1 AND b=2 AND c=3</code></li></ul></li><li><strong>失效的场景</strong>：<ul><li><code>WHERE b=2</code>（未使用最左列 <code>a</code>）</li><li><code>WHERE a=1 AND c=3</code>（跳过中间列 <code>b</code>）</li></ul></li></ul></li></ol><h4 id="MySQL中使用索引一定有效吗"><a href="#MySQL中使用索引一定有效吗" class="headerlink" title="MySQL中使用索引一定有效吗"></a>MySQL中使用索引一定有效吗</h4><table><thead><tr><th><strong>场景</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>低选择性索引</strong></td><td>索引列的值重复率高（如性别、状态字段），优化器认为全表扫描更快。</td></tr><tr><td><strong>索引列参与运算或函数</strong></td><td>例如 <code>WHERE YEAR(create_time) = 2023</code>，索引无法直接使用。</td></tr><tr><td><strong>隐式类型转换</strong></td><td>例如字符串列使用数字查询（<code>WHERE id = &#39;100&#39;</code>），导致索引失效。</td></tr><tr><td><strong>未遵循最左前缀原则</strong></td><td>复合索引 <code>(a, b, c)</code> 的查询跳过最左列 <code>a</code>，如 <code>WHERE b=2</code>。</td></tr><tr><td><strong>范围查询中断索引连续性</strong></td><td>范围查询（如 <code>a &gt; 10</code>）后，复合索引后续列的过滤条件无法直接使用索引。</td></tr><tr><td><strong>使用 <code>!=</code>、<code>NOT IN</code></strong></td><td>非等值查询无法有效利用索引。</td></tr><tr><td><strong>小表查询</strong></td><td>数据量较少时，优化器可能选择全表扫描而非索引。</td></tr><tr><td><strong>统计信息不准确</strong></td><td>索引的基数（Cardinality）统计不准确，导致优化器误判索引效率。</td></tr><tr><td><strong>1. 使用 <code>EXPLAIN</code> 分析执行计划</strong></td><td></td></tr><tr><td>通过 <code>EXPLAIN</code> 查看查询是否命中索引及索引使用细节：</td><td></td></tr></tbody></table><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre><p><strong>关键字段解析</strong>：</p><ul><li>**<code>type</code>**：访问类型，优先级从高到低：<br>  <code>const &gt; ref &gt; range &gt; index &gt; ALL</code>（<code>ALL</code> 表示全表扫描）。</li><li>**<code>key</code>**：实际使用的索引名称。</li><li>**<code>rows</code>**：预估扫描的行数，值越小越好。</li><li>**<code>Extra</code>**：额外信息，重点关注：<ul><li><code>Using index</code>：覆盖索引，无需回表。</li><li><code>Using where</code>：存储引擎层无法直接过滤，需 Server 层处理。</li><li><code>Using filesort</code>：需要额外排序，可能需优化索引或查询。</li></ul></li><li><a href="https://www.mianshiya.com/question/1780933295463231490">看这篇题解，非常好</a></li></ul><h4 id="599-MySQL-中的索引数量是否越多越好？为什么？"><a href="#599-MySQL-中的索引数量是否越多越好？为什么？" class="headerlink" title="599. MySQL 中的索引数量是否越多越好？为什么？"></a>599. MySQL 中的索引数量是否越多越好？为什么？</h4><ul><li><p><strong>索引并不是越多越好</strong>。因为索引<strong>不论从时间还是空间上都是有一定成本的</strong></p></li><li><p><strong>1）从时间上</strong></p><ul><li>每次对表中的数据进行增删改(INSERT、UPDATE 或 DELETE)的时候，索引也必须被更新，这会增加写入操作的开销。例如删除了一个 name 为面试鸭的记录，不仅主键索引上需要修改，如果 name 字段有索引，那么 name 索引也需要修改，所以<strong>索引越多需要修改的地方也就越多，时间开销就大了</strong>，并且 B+ 树可能会有页分裂、合并等操作，时间开销就会更大。</li><li>还有一点需要注意：MySQL 有个查询优化器，它需要分析当前的查询，选择最优的计划，这过程就需要考虑选择哪个索引的查询成本低。如果索引过多，那么会导致优化器耗费更多的时间在选择上，甚至可能因为数据的不准确而选择了次优的索引。</li></ul></li><li><p><strong>2）从空间上</strong></p><ul><li>每建立一个二级索引，都需要新建一个 B+ 树，默认每个数据页都是 16kb，如果数据量很大，索引又很多，占用的空间可不小。</li></ul></li></ul><h4 id="612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？"><a href="#612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？" class="headerlink" title="612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？"></a>612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？</h4><ul><li><em><strong>回答重点</strong></em><ul><li>explain 主要用来 SQL 分析，它主要的属性详解如下：</li><li><code>id</code>：查询的执行顺序的标识符，值越大优先级越高。简单查询的 id 通常为 1，复杂查询（如包含子查询或 UNION）的 id 会有多个。</li><li><code>select_type</code>（<strong>重要</strong>）：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。</li><li><code>table</code>：查询的数据表。</li><li><code>type</code>（<strong>重要</strong>）：访问类型，如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）等。一般来说，性能从好到差的顺序是：const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。</li><li><code>possible_keys</code>：可能用到的索引。</li><li><code>key</code>（<strong>重要</strong>）：实际用到的索引。</li><li><code>key_len</code>：用到索引的长度。</li><li><code>ref</code>：显示索引的哪一列被使用。</li><li><code>rows</code>（<strong>重要</strong>）：估计要扫描的行数，值越小越好。</li><li><code>filtered</code>：显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。</li><li><code>Extra</code>（<strong>重要</strong>）：额外信息，如 <code>Using index</code>（表示使用覆盖索引）、<code>Using where</code>（表示使用 WHERE 条件进行过滤）、<code>Using temporary</code>（表示使用临时表）、<code>Using filesort</code>（表示需要额外的排序步骤）。</li></ul></li><li><em><strong>type 详解：</strong></em><ul><li>system：表示查询的表只有一行（系统表）。这是一个特殊的情况，不常见。</li><li>const：表示查询的表最多只有一行匹配结果。这通常发生在查询条件是<strong>主键</strong>或<strong>唯一索引</strong>，并且是常量比较。</li><li>eq_ref：表示对于每个来自前一张表的行，MySQL 仅访问一次这个表。这通常发生在连接查询中使用主键或唯一索引的情况下。</li><li>ref：MySQL 使用非唯一索引扫描来查找行。查询条件使用的索引是非唯一的（如普通索引）。</li><li>range：表示 MySQL 会扫描表的一部分，而不是全部行。范围扫描通常出现在使用索引的范围查询中（如 <code>BETWEEN</code>、<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>）。</li><li>index：表示 MySQL 扫描索引中的所有行，而不是表中的所有行。即使索引列的值覆盖查询，也需要扫描整个索引。</li><li>all（性能最差）：表示 MySQL 需要扫描表中的所有行，即全表扫描。通常出现在没有索引的查询条件中。</li></ul></li></ul><h4 id="616-MySQL-中如何进行-SQL-调优？"><a href="#616-MySQL-中如何进行-SQL-调优？" class="headerlink" title="616. MySQL 中如何进行 SQL 调优？"></a>616. MySQL 中如何进行 SQL 调优？</h4><ul><li><p><em><strong>回答重点</strong></em></p><ul><li>平时进行 SQL 调优，主要是通过观察慢 SQL，然后利用 explain 分析查询语句的执行计划，识别性能瓶颈，优化查询语句。</li></ul><ol><li><p>合理设计索引，利用联合索引进行覆盖索引的优化，避免回表的发生，减少一次查询和随机 I&#x2F;O</p></li><li><p>避免 SELECT * ，只查询必要的字段</p></li><li><p>避免在 SQL 中进行函数计算等操作，使得无法命中索引</p></li><li><p>避免使用 %LIKE，导致全表扫描</p></li><li><p>注意联合索引需满足最左匹配原则</p></li><li><p>不要对无索引字段进行排序操作</p></li><li><p>连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描</p></li></ol></li><li><p>除此之外，还可以<strong>利用缓存</strong>来优化，一些变化少或者访问频繁的数据设置到缓存中，减轻数据库的压力，提升查询的效率。</p></li><li><p>还可以<strong>通过业务</strong>来优化，例如少展示一些不必要的字段，减少多表查询的情况，将列表查询替换成分页分批查询等等。</p></li><li><p><em><strong>扩展知识–慢 SQL</strong></em></p><ul><li><p>这是 MySQL 自带的日志记录，默认关闭，通过 <code>set global slow_query_log = &#39;ON&#39;</code> 即可开启。</p></li><li><p>通过 <code>show variables like &#39;%slow_query_log%&#39;</code> 即可查询当前慢日志是否开启，以及存储的路径。</p></li><li><p>通过 <code>set global long_query_time = 3</code> 即可设置慢 SQL 的阈值，3 就是 3 秒，当一个 SQL 执行的时间操作 3 秒，就会被记录到慢日志中。</p></li></ul></li></ul><h4 id="613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？"><a href="#613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？" class="headerlink" title="613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？"></a>613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</h4><ul><li><em><strong>功能上</strong></em>：<ul><li>1）<code>count(*)</code> 会统计表中所有行的数量，包括 <code>null</code> 值（不会忽略任何一行数据）。由于只是计算行数，不需要对具体的列进行处理，因此性能通常较高。</li><li>2）<code>count(1)</code> 和 <code>count(*)</code> 几乎没差别，也会统计表中所有行的数量，包括 <code>null</code> 值。</li><li>3）<code>count(字段名)</code> 会统计指定字段不为 <code>null</code> 的行数。这种写法会对指定的字段进行计数，只会统计字段值不为 <code>null</code> 的行。</li></ul></li><li><em><strong>效率上</strong></em>：<ul><li><code>count(1)</code> 和 <code>count(*)</code> 效率一致</li><li><code>count(字段)</code> 的查询就是全表扫描(如果对应的字段没有索引，如果有索引则用索引)，正常情况下它还需要判断字段是否是 null 值，因此理论上会比 <code>count(1)</code> 和 <code>count(*)</code> 慢。</li><li>但是如果字段不为 null，例如是主键，那么理论上也差不多，而且本质上它们的统计功能不一样，在需要统计 null 的时候，只能用 <code>count(1)</code> 和 <code>count(*)</code>，不需要统计 null 的时候只能用<code>count(字段)</code>，所以也不用太纠结性能问题。</li></ul></li><li><em><strong>扩展知识</strong></em><ul><li><p>在 MyISAM 中，由于只有表锁，因此它把每张表的总数单独记录维护（表锁使得对表的修改是串行，因此能维护总数），所以 <code>count(*)</code> 非常快，因为等于直接返回一个字段。当然，<strong>前提是不需要条件过滤而是直接返回整表数据</strong>。</p></li><li><p>而 InnoDB 由于支持行锁，所以会有很多并发来修改表的数据，因此无法维护记录总数，但是 InnoDB 对<code>count(*)</code>和<code>count(1)</code>也做了一定的优化。</p></li><li><p>count 的字段如果是主键，由于主键索引保存的是整行记录，占据的空间和内存都比较大，此时表中如果还有其它二级索引，那么成本会更低，因此 InnoDB 会评估这个成本选择合适的索引扫描。当然，这个前提也是不能有对应的条件过滤等功能。</p></li></ul></li><li><img src="/img/Pasted_image_20250314103948.png"></li><li><img src="/img/Pasted_image_20250314104003.png"></li></ul><h4 id="615-MySQL-中-varchar-和-char-有什么区别？"><a href="#615-MySQL-中-varchar-和-char-有什么区别？" class="headerlink" title="615. MySQL 中 varchar 和 char 有什么区别？"></a>615. MySQL 中 varchar 和 char 有什么区别？</h4><ul><li><p><img src="/img/Pasted_image_20250314105731.png"></p></li><li><p>理论上来说 CHAR 会比 VARCHAR 快，因为 VARCHAR 长度不固定，处理需要多一次运算，但是实际上这种运算耗时微乎其微，而固定大小在很多场景下比较浪费空间，除非存储的字符确认是固定大小或者本身就很短，不然业务上推荐使用 VARCHAR。</p></li><li><p><em><strong>拓展</strong></em></p><ul><li><p>MySQL 执行 orderby 排序的时候，会利用 sort_buffer。</p></li><li><p>假设 a、b、c 都为 varchar 类型，当前要执行<code>select a,b,c from t1 where a = &#39;面试鸭&#39; order by b;</code></p></li><li><p>MySQL 计算 a b c 总长度比较长，sort_buffer 可能放不下，就会使用<strong>双路排序</strong>，即 sort_buffer 里存放需要排序的字段 b 和 id 进行排序，待排完后，再通过 id 回表查询得到a、b、c 字段。这样就多了回表的一步，性能比较差。</p></li><li><p><img src="/img/Pasted_image_20250314110644.png"></p></li><li><p>如果 select 字段长度少，那么就可以使用<strong>单路排序</strong>，即将 select 的数据都放入到 sort_buffer 中，排完序后直接返回给客户端。</p></li><li><p><img src="/img/Pasted_image_20250314110659.png"></p></li><li><p>这里计算 a、b、c 长度依据的就是 varchar(n) 中的 n，所以如果 n 设置很大，虽然占用空间是动态的，但是会隐性影响排序的性能。</p></li></ul></li><li><p><em><strong>varchar支持的最大长度</strong></em></p><blockquote><p>mysql column length is within the maximum length of 65,535 bytes</p></blockquote></li><li><p>因为最大行长度有限，所以要计算 VARCHAR 支持最大长度，仅当一行只有一个 VARCHAR 字段时，这个 VARCHAR 字段能达到最大长度（没有别的字段来占用空间）。</p></li><li><p>最大行长度是 65535 字节，如果值允许为 null，则需要额外 1bit 标记是否为 null（mysql 最对于 null 值是额外用一个 null值列表存储的。当前只有一个 VARCHAR 字段，需要用 1 个 bit 标记它的 null 值组成 null 值列表，mysql 要求 null 值列表最少需要一个字节，所以需要占用 1 个字节），又因为 VARCHAR 列的长度是可变的，需要 1 到 2 个字节（字符长度超过 255，则使用两个字节）用于存储字符串的长度信息。</p></li><li><p>所以支持的最大长度是 <code>65535 - 2 = 65533</code>，如果允许为 null 则是 <code>65532</code>。</p></li><li><p>以上是字节数，实际的字符又取决于使用的字符集。</p><ul><li>UTF-8 字符集：每个字符最大占用 3 字节（但也可以是 1 字节、2 字节或 3 字节，具体取决于字符的实际编码）。因此，最大字符数会受限于字符集的编码方式。如果使用 UTF-8，最大字符数大约是 21844 字符（65533 ÷ 3）。</li><li>UTF-16 字符集：每个字符通常占用 2 字节。最大字符数大约是 32766 字符（65533 ÷ 2）。</li><li>Latin1 字符集：每个字符占用 1 字节，所以最大字符数为 65533 字符。</li></ul></li><li><p>在定义 <code>VARCHAR(n)</code> 时，n 代表的是字符的个数，而不是字节数。</p></li></ul><h4 id="600-请详细描述-MySQL-的-B-树中查询数据的全过程"><a href="#600-请详细描述-MySQL-的-B-树中查询数据的全过程" class="headerlink" title="600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程"></a>600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程</h4><p>1）数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点<br>2）叶子节点存储实际的数据行记录，但是一页有 16kb 大小，存储的数据行不止一条<br>3）叶子节点中数据行以组的形式划分，利用<strong>页目录</strong>结构，通过二分查找可以定位到对应的组<br>4）定位组后，利用链表遍历就可以找到对应的数据行</p><ul><li><em><strong>详细流程</strong></em><ul><li><p>数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点。</p></li><li><p><img src="/img/Pasted_image_20250314112930.png"></p></li><li><p>定位到叶子节点后，因为一片叶子默认有 16k 大小，所以理论上可以存多条记录。叶子节点的实际构造如下图所示：</p></li><li><p><img src="/img/Pasted_image_20250314112940.png"></p></li><li><p>从上图可以知晓，叶子节点有<strong>页目录</strong>结构，它其实就是一个索引，通过它可以快速找到记录。</p></li><li><p>页目录分为了多个槽，每个槽都指向对应一个分组内的最大记录，每个分组内都会包含若干条记录。</p></li><li><p>通过<strong>二分查询</strong>，利用槽就能直接定位到记录所在的组，从而就能获取到对应的记录。</p></li><li><p>举个例子，现在有 5 个槽，如果想查找主键为 3 的记录，此时的流程是：</p></li><li><p>1）通过二分得到槽的中间位置，<code>low = 0</code>，<code>high = 4</code>，<code>（0+4)/2 = 2</code>; </p></li><li><p>2）通过槽定位到第二个分组中的主键为 4 的记录，4 大于 3，<code>low = 0</code> 不变，<code>high = 2</code>; </p></li><li><p>3）继续二分 <code>(0+2)/2 = 1</code>; 槽 1 中主键 2 小于 3，<code>low = 1</code>，<code>high = 2</code>; </p></li><li><p>4）此时 <code>high - low = 1</code>，可以确定值在 high 即槽 2 中，但是槽 2 只能定位到主键为 4 的记录，又因为槽之间是挨着的，所以可以得到槽 1 的位置，从槽 1 入手拿到 主键 2 的记录，然后因为记录是通过单向链表串起来的，往下遍历即可定位到主键 3 的记录。</p></li><li><p>以上就是利用二分查询的定位流程。通过槽可找到对应记录所在的组，或能直接定位到记录，或还需通过链表遍历找到对应的数据。</p></li><li><p>实际上，每个分组的记录数是有规定的，图中做了省略只画了两条，InnoDB 规定：</p><ul><li>第一个分组只有一条记录</li><li>中间的分组 4-8 条记录</li><li>最后一个分组 1-8 条记录</li></ul></li><li><p>因此不必担心遍历很长的链表导致性能问题。</p></li></ul></li></ul><h4 id="602-MySQL-是如何实现事务的？"><a href="#602-MySQL-是如何实现事务的？" class="headerlink" title="602. MySQL 是如何实现事务的？"></a>602. MySQL 是如何实现事务的？</h4><h4 id="604-MySQL-中的-MVCC-是什么？"><a href="#604-MySQL-中的-MVCC-是什么？" class="headerlink" title="604. MySQL 中的 MVCC 是什么？"></a>604. MySQL 中的 MVCC 是什么？</h4><h4 id="106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？"><a href="#106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？" class="headerlink" title="106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？"></a>106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？</h4>]]></content>
    
    
    <categories>
      
      <category>面试八股题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>#MySQL</tag>
      
      <tag>#八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
