

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/project/img/w.png">
  <link rel="icon" href="/project/img/w.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="十众">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL 的存储引擎有哪些？它们之间有什么区别？ MySql共有10个不同的存储引擎，其中最主要的为InnoDB和MyISAM，其他还有Memory, NDB, ARCHIVE, CSV, Blackhole, Merge, Federated, Example InnoDB 支持事务、行级锁和外键。 提供高并发性能，适用于高负载的 OLTP 应用。 数据以聚集索引的方式存储，提高检索效率">
<meta property="og:type" content="article">
<meta property="og:title" content="1.MySQL">
<meta property="og:url" content="https://vvx94.github.io/project/posts/aaba9777.html">
<meta property="og:site_name" content="听风">
<meta property="og:description" content="MySQL 的存储引擎有哪些？它们之间有什么区别？ MySql共有10个不同的存储引擎，其中最主要的为InnoDB和MyISAM，其他还有Memory, NDB, ARCHIVE, CSV, Blackhole, Merge, Federated, Example InnoDB 支持事务、行级锁和外键。 提供高并发性能，适用于高负载的 OLTP 应用。 数据以聚集索引的方式存储，提高检索效率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311110109.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311111828.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311144321.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311145818.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311150056.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311150426.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted%20image%2020250312132622.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted%20image%2020250312132750.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314103948.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314104003.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314105731.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314110644.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314110659.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314112930.png">
<meta property="og:image" content="https://vvx94.github.io/project/img/Pasted_image_20250314112940.png">
<meta property="article:published_time" content="2025-03-15T03:18:33.000Z">
<meta property="article:modified_time" content="2025-03-15T03:40:38.965Z">
<meta property="article:author" content="十众">
<meta property="article:tag" content="#MySQL">
<meta property="article:tag" content="#八股">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://vvx94.github.io/project/img/Pasted_image_20250311110109.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>1.MySQL - 听风</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/project/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/project/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/project/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vvx94.github.io","root":"/project/","version":"1.9.5","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/project/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/project/js/utils.js" ></script>
  <script  src="/project/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/project/">
      <strong>十众</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/project/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/project/img/bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="1.MySQL"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-15 11:18" pubdate>
          2025年3月15日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          4 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">1.MySQL</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="MySQL-的存储引擎有哪些？它们之间有什么区别？"><a href="#MySQL-的存储引擎有哪些？它们之间有什么区别？" class="headerlink" title="MySQL 的存储引擎有哪些？它们之间有什么区别？"></a>MySQL 的存储引擎有哪些？它们之间有什么区别？</h4><ul>
<li>MySql共有10个不同的存储引擎，其中最主要的为<em>InnoDB和MyISAM</em>，其他还有<em>Memory, NDB, ARCHIVE</em>, CSV, Blackhole, Merge, Federated, Example</li>
<li><em><strong>InnoDB</strong></em><ul>
<li>支持<em>事务、行级锁和外键</em>。</li>
<li>提供<em>高并发性能</em>，适用于高负载的 OLTP 应用。</li>
<li>数据以<em>聚集索引</em>的方式存储，提高检索效率</li>
</ul>
</li>
<li><em><strong>MyISAM</strong></em><ul>
<li><em>不支持事务和外键</em>，使用表级锁。</li>
<li>适合<em>读取多、更新少</em>的场景，如数据仓库。</li>
<li>具有较高的读性能和较快的表级锁定。</li>
</ul>
</li>
<li><em><strong>MEMORY</strong></em><ul>
<li>数据存储在内存中，速度快，但数据在服务器重启后丢失。</li>
<li>适用于临时数据存储或快速缓存。</li>
</ul>
</li>
<li><em><strong>NDB (NDBCluster)：</strong></em><ul>
<li>支持高可用性和数据分布，适合大规模分布式应用</li>
<li>提供行级锁和自动分区。</li>
</ul>
</li>
<li><em><strong>ARCHIVE</strong></em>：<ul>
<li>用于存储大量历史数据，支持高效的插入和压缩。</li>
<li>不支持索引，适合日志数据存储。</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="InnoDB学习记录"><a href="#InnoDB学习记录" class="headerlink" title="InnoDB学习记录"></a>InnoDB学习记录</h4><ul>
<li><p>昨晚看了两三个多小时，依旧没把这题看完，险些道心破碎，结果今天一看，嘿，原来直接搞定了一堆题目，爽了。</p>
</li>
<li><p><em><strong>InnoDB（详细可见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.4/en/innodb-introduction.html">官方文档</a>）</strong></em></p>
<ul>
<li>一个兼顾高可靠性和高性能的通用存储引擎。在 MySQL 8.4 中，<code>InnoDB</code> 是默认的 MySQL 存储引擎。</li>
<li>主要优势：<ul>
<li>DML操作遵循 ACID 模型，事务具有<em>提交、回滚和崩溃恢复</em>功能，以保护用户数据</li>
<li><em>行级锁和 Oracle 风格的一致性读取</em>可以提高多用户并发和性能</li>
<li><em>聚簇索引</em>的方式可最大限度减少逐渐查找的I&#x2F;O</li>
<li>为了保持数据完整性，<code>InnoDB</code> 支持 <code>FOREIGN KEY</code> 约束</li>
</ul>
</li>
<li>数据存储结构<ul>
<li><em>表空间</em>：数据存储在表空间文件（<code>.ibd</code>）中，包含 <strong>数据段</strong>（存储行数据）、<strong>索引段</strong>（存储索引）和 <strong>回滚段</strong>（存储事务回滚信息）。</li>
<li>页：数据以固定大小的 <strong>页（16KB）</strong> 为单位存储，每个页包含行数据，页目录，页头，文件头</li>
</ul>
</li>
<li><em>功能</em>：<ul>
<li><img src="/project/img/Pasted_image_20250311110109.png" srcset="/project/img/loading.gif" lazyload></li>
<li>基于文档中的表格，可以发现支持的索引方式有以下几种：<ul>
<li>B+树索引（聚簇索引）<ul>
<li>注意：支持聚簇索引，但是不支持聚簇数据库（cluster database support）</li>
</ul>
</li>
<li>全文搜索索引（也即倒排索引）</li>
<li>哈希索引</li>
<li>R-tree索引</li>
<li>不支持T-tree索引</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>几个提及的相关概念在下面做详细解释</strong></em></li>
</ul>
</li>
<li><p><em><strong>B树和B+树</strong></em></p>
<ul>
<li>在了解<em><strong>B树</strong></em>之前，想必大家已经了解过AVL树和红黑树等，这些二叉树虽然已经能实现<code>O(logn)</code>级别的增删改查复杂度，但是我们也需要意识到，同为<code>O(logn)</code>亦有区别。</li>
<li>让我们看看两种数据结构的图示：<ul>
<li><img src="/project/img/Pasted_image_20250311111828.png" srcset="/project/img/loading.gif" lazyload></li>
</ul>
</li>
<li>在查询时，需要先从硬盘中读取数据再做后续操作，假设需要查询有序二叉树中的F，需要查询3次才能找到对应节点，也即3次I&#x2F;O操作，<em>这种I&#x2F;O操作非常耗时，且与树的高度正相关</em>，相比而言内存中数据处理耗费的时间可以忽略不计。</li>
<li>那么，怎么才能减少I&#x2F;O操作呢？一种直观且自然的想法就是压缩树的高度。这就是B树的基本目标：<em>为磁盘存储优化，通过降低树的高度减少磁盘访问次数，支持随机读写</em></li>
<li><strong>那么B树的节点结构是怎么设计的</strong>？<ul>
<li>首先，每个节点最多包含m个子节点，有m-1个分支，被称为m阶B树，阶数通常由磁盘块的大小决定，例如每个节点存储一个磁盘块</li>
<li>非叶子节点存储键和指针，同时<em>直接存储数据</em>（注意，与B+树的一个主要区别）</li>
<li>所有叶子位于同一层，以此确保树的平衡性</li>
<li>在设计上，内部节点至少有$\lceil \frac{m}{2} \rceil$个子节点</li>
</ul>
</li>
<li><strong>核心操作</strong>：<ul>
<li>查找：从根节点开始逐层比较，找到目标数据所在子树，最后在叶子节点或内部节点找到数据</li>
<li>插入：在叶子节点插入，可能导致节点分裂（节点键数超过<code>n-1</code>），会在$\lceil \frac{m}{2} \rceil$处分裂，分裂后的中间键提升到父节点，如果父节点键数超过m-1，会继续向上分裂</li>
<li>删除：<ul>
<li>如果是内部节点，会用叶子节点取代内部节点的位置，从而转化为叶子节点的删除</li>
<li>如果删除叶子节点，当节点键数小于$\lceil \frac{m}{2} \rceil-1$，会需要借键或与兄弟节点合并</li>
</ul>
</li>
</ul>
</li>
<li><em><strong>B+树</strong></em><ul>
<li>在B树基础上进一步<em>优化了顺序访问和范围查询</em>，尤其适合<em><strong>数据库索引</strong></em></li>
<li>节点结构（<em>注意与B树的不同</em>）<ul>
<li><strong>内部节点仅存储键和指针</strong>，<strong>不存储实际数据</strong>。</li>
<li><strong>所有数据存储在叶子节点</strong>，叶子节点通过<em>指针</em>形成<em>双向链表，支持高效顺序扫描</em>。</li>
<li>叶子节点包含所有键的副本，且键值按顺序排列。</li>
<li>阶数类似于B树，但是数据仅存在于叶子节点</li>
</ul>
</li>
<li><img src="/project/img/Pasted_image_20250311144321.png" srcset="/project/img/loading.gif" lazyload></li>
<li><strong>优点</strong><ul>
<li><strong>范围查询高效</strong>：叶子节点的链表结构支持线性遍历</li>
<li><strong>更高的扇出（Fan-out）</strong>：内部节点不存数据，可容纳更多键，树更矮，I&#x2F;O更少</li>
<li><strong>查询稳定性</strong>：所有查询均需访问到叶子节点，路径长度一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>聚簇索引和非聚簇索引</strong></em></p>
<ul>
<li>先放上聚簇索引和非聚簇索引的示意图（源自B站up<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17D4y1e78A">猿人林克</a>）</li>
<li><img src="/project/img/Pasted_image_20250311145818.png" srcset="/project/img/loading.gif" lazyload></li>
<li><img src="/project/img/Pasted_image_20250311150056.png" srcset="/project/img/loading.gif" lazyload></li>
<li><img src="/project/img/Pasted_image_20250311150426.png" srcset="/project/img/loading.gif" lazyload></li>
<li><strong>聚簇索引</strong>在叶子节点中记录的是每行的真实数据，非叶子节点中记录的是每行的key<ul>
<li>数据行的物理顺序与索引键值的逻辑顺序一致。</li>
<li>每个表<strong>只能有一个聚簇索引</strong>（因为数据只能按一种物理顺序存储）。</li>
<li>在多数数据库（如MySQL InnoDB）中，<strong>主键默认是聚簇索引</strong>。若未定义主键，则选择第一个<em>唯一非空索引（UNIQUE）</em> 替代；若无，隐式生成一个<em>隐藏的聚簇索引</em>。</li>
<li>优点：<ul>
<li><strong>范围查询高效</strong>：数据物理连续，减少磁盘I&#x2F;O</li>
<li><strong>排序和分组优化</strong>：若查询的 <code>ORDER BY</code> 或 <code>GROUP BY</code> 列是聚簇索引键，无需额外排序。</li>
<li><strong>覆盖索引优势</strong>：  若查询仅需聚簇索引列，无需回表。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>插入&#x2F;更新开销大</strong>：  插入数据到非末尾位置可能导致<strong>页分裂</strong>（Page Split），产生碎片，降低性能。</li>
<li><strong>维护成本高</strong>：  频繁更新的列不适合作为聚簇索引键。</li>
</ul>
</li>
<li>适用场景：<ul>
<li>主键或频繁用于范围查询的列</li>
<li>需要频繁排序或分组的列。</li>
</ul>
</li>
</ul>
</li>
<li><strong>非聚簇索引</strong>(Secondary Indexes)又被称为二级索引，除了聚簇索引外的每一个索引都会构成一个非聚簇索引树，叶子节点记录的是每行数据在聚簇索引中的key,<ul>
<li>数据行的物理顺序与索引键值无关。</li>
<li>每个表可创建<strong>多个非聚簇索引</strong>（如为不同查询条件优化）。</li>
<li><strong>回表（Bookmark Lookup）</strong>：  通过索引找到键值后，需根据<em>指针回表</em>查询完整数据行。（也即图中显示的到聚簇索引中查找，<em>首先通过索引定位到对应页，然后再根据行的物理地址找到所需的数据行</em>）</li>
<li>优点：<ul>
<li><strong>插入&#x2F;更新开销低</strong>：  不改变数据物理顺序，维护成本低于聚簇索引。</li>
<li><strong>多维度优化</strong>：  可为不同查询条件创建多个索引。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>查询效率依赖回表</strong>：若查询字段未完全包含在索引中，需额外I&#x2F;O访问数据页。</li>
<li><strong>空间占用</strong>：多个索引会占用更多存储空间。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>高频查询的 <code>WHERE</code> 条件列（如用户名、商品类别）。</li>
<li>需要避免全表扫描的查询列。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>R-tree索引和T-tree索引</p>
<ul>
<li><strong>T-tree(事务树)</strong><ul>
<li>是一种专为<em>内存数据库</em>设计的高效索引结构，如如 Oracle TimesTen、SAP HANA等，结合了 <strong>AVL树</strong>（平衡二叉搜索树）和 <strong>B树</strong> 的特点。</li>
<li><strong>节点结构</strong>：<ul>
<li>每个节点包含 <strong>多个键值对</strong>（类似B树），但节点容量较小（通常为几十个键）。</li>
<li>每个节点维护一个 <strong>有序键值范围</strong>，并记录子节点的最小&#x2F;最大值。</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li>内存优化：减少指针数量，提高缓存利用率。</li>
<li>适合频繁更新的内存数据库（如实时交易系统）</li>
</ul>
</li>
</ul>
</li>
<li><strong>R-tree(空间索引树)</strong><ul>
<li>专为多维数据（如地理坐标、图形）设计的空间索引结构，支持高效范围查询</li>
<li><strong>节点结构</strong>：<ul>
<li>每个节点代表一个 <strong>最小边界矩形（MBR, Minimum Bounding Rectangle）</strong>，涵盖其子节点或数据对象的所有空间范围。</li>
<li>叶子节点存储实际数据对象的空间范围，非叶子节点存储子节点的MBR。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><em><strong>回到本题，继续学习InnoDB和MyISAM的区别</strong></em></p>
<ul>
<li><strong>InnoDB</strong>：现代数据库的标配，以 <strong>事务安全</strong> 和 <strong>高并发</strong> 为核心优势。</li>
<li><strong>MyISAM</strong>：仅适用于 <strong>读多写少</strong> 且 <strong>无需事务</strong> 的遗留场景。</li>
<li>事务与锁：<ul>
<li>InnoDB:<ul>
<li>支持事务的提交（COMMIT）和回滚（ROLLBACK），保证数据一致性。</li>
<li>默认使用 <strong>行级锁</strong>（通过索引实现），支持高并发写入。</li>
<li>通过 <strong>MVCC</strong>（多版本并发控制）实现非阻塞读（<code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别）。</li>
</ul>
</li>
<li>MyISAM:<ul>
<li><strong>表级锁</strong>：任何写操作会锁住整个表，导致并发性能急剧下降。</li>
<li>高并发场景下，<code>INSERT</code> 和 <code>SELECT</code> 可能互相阻塞。</li>
</ul>
</li>
</ul>
</li>
<li>索引与数据存储<ul>
<li><strong>InnoDB</strong>：<ul>
<li><strong>聚簇索引</strong>：数据按主键顺序物理存储，二级索引存储主键值（需回表查询）。</li>
<li>建议使用 <strong>自增整数</strong>（避免页分裂）</li>
</ul>
</li>
<li><strong>MyISAM</strong>：<ul>
<li><strong>非聚簇索引</strong>：数据与索引分离，所有索引均存储数据行的物理地址（如偏移量）。</li>
<li>主键与普通索引无本质区别，查询时需两次寻址（索引→数据文件）</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能与适用场景</strong><ul>
<li><strong>InnoDB 优势场景</strong>：<ul>
<li><strong>OLTP（联机事务处理）</strong>：如电商订单、支付系统，需高并发写入和事务安全。</li>
<li><strong>数据一致性要求高</strong>：如银行转账、库存扣减，依赖事务回滚和锁机制。</li>
<li><strong>大数据量范围查询</strong>：聚簇索引优化范围扫描（如 <code>WHERE date BETWEEN ...</code>）。</li>
</ul>
</li>
<li><strong>MyISAM 优势场景</strong>：<ul>
<li><strong>OLAP（联机分析处理）</strong>：如日志分析、报表统计，读多写少且无需事务。</li>
<li><strong>全文搜索（旧版本 MySQL）</strong>：MyISAM 早期版本全文索引性能更优（MySQL 5.6+ InnoDB 已支持）。</li>
<li><strong>只读或低频写入表</strong>：如静态配置表、归档数据表。</li>
</ul>
</li>
</ul>
</li>
<li><strong>崩溃恢复以及数据安全</strong><ul>
<li><strong>InnoDB</strong>：<ul>
<li>通过 <strong>Redo Log（重做日志）</strong> 和 <strong>Undo Log（回滚日志）</strong> 保证崩溃后数据一致。</li>
<li>支持 <strong>Double Write Buffer</strong> 防止部分写（Partial Write）导致数据损坏。</li>
</ul>
</li>
<li><strong>MyISAM</strong>：<ul>
<li>无事务日志，崩溃后需手动执行 <code>CHECK TABLE</code> 和 <code>REPAIR TABLE</code>。</li>
<li>数据损坏风险更高（如服务器意外断电可能导致表不可用）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>InnoDB</strong></th>
<th><strong>MyISAM</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>事务支持</strong></td>
<td>✅ 支持 ACID 事务</td>
<td>❌ 不支持事务</td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>行级锁（默认）</td>
<td>表级锁</td>
</tr>
<tr>
<td><strong>外键约束</strong></td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>崩溃恢复能力</strong></td>
<td>✅ 支持崩溃后自动恢复（Redo Log）</td>
<td>❌ 需手动修复（<code>REPAIR TABLE</code>）</td>
</tr>
<tr>
<td><strong>索引类型</strong></td>
<td>聚簇索引（数据与主键绑定）</td>
<td>非聚簇索引（数据与索引分离）</td>
</tr>
<tr>
<td><strong>MVCC（多版本并发控制）</strong></td>
<td>✅ 支持（通过 Undo Log 实现）</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td><strong>全文索引</strong></td>
<td>✅ MySQL 5.6+ 支持</td>
<td>✅ 原生支持（较早版本）</td>
</tr>
<tr>
<td><strong>缓存机制</strong></td>
<td>缓存数据和索引（缓冲池）</td>
<td>仅缓存索引（Key Buffer）</td>
</tr>
<tr>
<td><strong>存储文件结构</strong></td>
<td><code>.ibd</code>（数据+索引）或共享表空间（<code>ibdata</code>）</td>
<td><code>.MYD</code>（数据）、<code>.MYI</code>（索引）、<code>.frm</code>（表结构）</td>
</tr>
<tr>
<td><strong>COUNT(*) 优化</strong></td>
<td>需全表扫描或统计近似值</td>
<td>✅ 直接返回缓存的行数（无需扫描）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="949-MySQL-三层-B-树能存多少数据？"><a href="#949-MySQL-三层-B-树能存多少数据？" class="headerlink" title="949. MySQL 三层 B+ 树能存多少数据？"></a>949. MySQL 三层 B+ 树能存多少数据？</h4><ul>
<li>假设参数：<ul>
<li>页大小（Page Size）：在 MySQL 的 InnoDB 存储引擎中，默认的页大小是 16KB（16 * 1024 &#x3D; 16384 字节）。</li>
<li>键值大小（Key Size）：假设索引键值为 BIGINT 类型，占用 8 字节。</li>
<li>指针大小（Pointer Size）：用于指向子节点或数据记录的指针，通常占用 6 字节。</li>
<li>记录大小（Record Size）：假设每条数据记录占用 1024 字节（1KB）。</li>
</ul>
</li>
<li>对于叶子节点：存储数据，可以存储$16KB \div 1KB &#x3D; 16$条</li>
<li>对于第二层：一个索引占据$8+6&#x3D;14byte$ 则一页可以存储$16KB \div 14byte &#x3D; (16 \times 1024) byte \div 14byte &#x3D; 1170$</li>
<li>对于根节点：可以存储1170个索引</li>
<li>综合：$1170 \times 1170 \times 16 &#x3D; 21902400$</li>
<li>这也说明，当数据量超过2000万条时，需要进行分表操作</li>
</ul>
<h4 id="594-MySQL-索引的最左前缀匹配原则是什么？"><a href="#594-MySQL-索引的最左前缀匹配原则是什么？" class="headerlink" title="594. MySQL 索引的最左前缀匹配原则是什么？"></a>594. MySQL 索引的最左前缀匹配原则是什么？</h4><p>MySQL 的 <strong>最左前缀匹配原则（Leftmost Prefix Principle）</strong> 是联合索引（Composite Index）的核心使用规则，直接影响索引是否生效及查询效率。以下从 <strong>原理、示例、场景优化</strong> 三个维度详细解析：</p>
<hr>
<p><em><strong>一、原理详解</strong></em></p>
<ol>
<li><strong>联合索引的结构</strong><ul>
<li>假设创建联合索引 <code>INDEX idx_a_b_c (a, b, c)</code>，索引在磁盘中的存储逻辑如下：<ul>
<li><strong>按列顺序排序</strong>：先按 <code>a</code> 排序 → <code>a</code> 相同再按 <code>b</code> 排序 → <code>a</code> 和 <code>b</code> 都相同最后按 <code>c</code> 排序。</li>
<li><strong>类似电话簿</strong>：先按姓氏排序，再按名字排序，最后按城市排序。</li>
</ul>
</li>
</ul>
</li>
<li><strong>最左前缀规则</strong><br>查询时，<strong>必须从索引的最左列开始</strong>，且<strong>不能跳过中间的列</strong>。以下情况索引可能生效：<br>- 使用 <code>a</code> 列 → ✅<br>- 使用 <code>a + b</code> → ✅<br>- 使用 <code>a + b + c</code> → ✅<br>- 使用 <code>a + c</code> → ⚠️ <strong>部分生效</strong>（仅 <code>a</code> 生效，<code>c</code> 不生效）<br>- 使用 <code>b</code> 或 <code>c</code> 或 <code>b + c</code> → ❌ 不生效</li>
<li><strong>底层原因</strong><ul>
<li><strong>索引有序性</strong>：索引按 <code>(a, b, c)</code> 的顺序构建，跳过左列会导致后续列无序，无法利用二分查找。</li>
<li><strong>B+树结构</strong>：非最左列的查询需遍历整个索引树，效率可能不如全表扫描。</li>
</ul>
</li>
</ol>
<hr>
<p>二、示例分析</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">#  示例表结构
CREATE TABLE users (
    id INT PRIMARY KEY,
    country VARCHAR(50),
    city VARCHAR(50),
    age INT,
    INDEX idx_country_city_age (country, city, age)
);</code></pre>

<ol>
<li><p><strong>生效的查询场景</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ✅ 使用最左列 country</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span><span class="token punctuation">;</span>

<span class="token comment">-- ✅ 使用 country + city</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span><span class="token punctuation">;</span>

<span class="token comment">-- ✅ 使用 country + city + age（全列匹配）</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span> <span class="token operator">AND</span> age <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p><strong>部分生效的场景</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ⚠️ 仅 country 生效，age 无法走索引（中间跳过了 city）</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token comment">-- ⚠️ 范围查询后，后续列无法走索引（city='Beijing' 生效，但 age 不生效）</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users 
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">></span> <span class="token string">'A'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">-- 仅 country + city 生效</span></code></pre></li>
<li><p><strong>不生效的场景</strong></p>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- ❌ 未使用最左列 country</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> city <span class="token operator">=</span> <span class="token string">'Beijing'</span><span class="token punctuation">;</span>

<span class="token comment">-- ❌ 跳过了中间列 city</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong>如果遇到范围查询(&gt;、&lt;)，就会停止匹配</strong>。</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&gt;1, b&#x3D;2, c&#x3D;3;</code></pre></li>
</ol>
<ul>
<li><p>所谓的停止匹配指的是：a 可以用上联合索引，但是 b 和 c 却不行。因为 a 需要先经过范围查询，此时经过筛选得到 b 和 c 的数据是无序的。比如 a 为 1 和 a 为 2 数据之间 b 和 c 是无序的，因此无法利用索引查询。</p>
</li>
<li><p><strong>如果遇到如 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、前缀like（xx%）的范围查询，则不会停止匹配</strong>。因为这些查询包含一个等值判断，可以直接定位到某个数据，然后往后扫描即可。</p>
</li>
</ul>
<p>例如：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&gt;&#x3D;1, b&#x3D;2, c&#x3D;3;</code></pre>

<ul>
<li><p>查询可以定位到 a&#x3D;1 这条数据，然后往后遍历即可，而定<strong>位到的 a&#x3D;1 数据内，b 和 c 是有序的，因此可以利用索引查询</strong>。</p>
</li>
<li><p>而以下的查询则可以全部用上联合索引：</p>
<pre class="language-mysql" data-language="mysql"><code class="language-mysql">where a&#x3D;1, b&#x3D;2, c&gt;3;</code></pre>
</li>
<li><p>因为 a 和 b 是等值查询的情况下，c 是有序的，有序就可以用上索引。</p>
</li>
</ul>
<hr>
<p>三、场景优化策略</p>
<ol>
<li><strong>合理设计联合索引顺序</strong></li>
</ol>
<ul>
<li><strong>高频查询条件在前</strong>：将最常用的列放在索引左侧。</li>
</ul>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 假设查询条件多为 country + city，而非单独 country</span>
<span class="token keyword">INDEX</span> idx_country_city <span class="token punctuation">(</span>country<span class="token punctuation">,</span> city<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><strong>区分度高的列在前</strong>：区分度高的列（唯一值多）能更快缩小查询范围。  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- country 有 100 个值，city 有 1000 个值 → 优先 city 在前？</span>
<span class="token comment">-- 错误！必须结合查询条件频率，不能只看区分度。</span></code></pre></li>
</ul>
<ol start="2">
<li><strong>处理范围查询</strong></li>
</ol>
<ul>
<li><strong>范围查询后的列无法走索引</strong>：  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users 
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">></span> <span class="token string">'Beijing'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token comment">-- 实际生效索引：country + city（age 无法利用索引）</span></code></pre></li>
<li><strong>优化方案</strong>：将等值查询列放在范围查询列之前。<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 如果查询条件多为 country + age，且 age 是范围查询：</span>
<span class="token comment">-- 需要重新设计索引，但受最左前缀限制，可能需要单独创建 (country, age) 索引。</span></code></pre></li>
</ul>
<ol start="3">
<li><strong>覆盖索引优化</strong></li>
</ol>
<ul>
<li><strong>无需回表</strong>：若查询字段全部在索引中，即使跳过中间列，也可能触发覆盖索引。<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span>
<span class="token keyword">SELECT</span> country<span class="token punctuation">,</span> city<span class="token punctuation">,</span> age <span class="token keyword">FROM</span> users 
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">-- ⚠️ 使用覆盖索引（Extra: Using index）</span></code></pre></li>
</ul>
<ol start="4">
<li><strong>索引下推（Index Condition Pushdown, ICP）</strong></li>
</ol>
<ul>
<li><strong>MySQL 5.6+ 特性</strong>：将 <code>WHERE</code> 条件中索引列的过滤下推到存储引擎层。  <pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 索引: (country, city, age)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users 
<span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">'China'</span> <span class="token operator">AND</span> city <span class="token operator">LIKE</span> <span class="token string">'B%'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
<span class="token comment">-- 即使 city 是模糊查询，ICP 会在引擎层过滤 age=25 的记录，减少回表次数。</span></code></pre></li>
</ul>
<h4 id="593-MySQL中的回表是什么"><a href="#593-MySQL中的回表是什么" class="headerlink" title="593.MySQL中的回表是什么"></a>593.MySQL中的回表是什么</h4><ul>
<li>“回表” 是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，<strong>这个过程被称为回表</strong>。</li>
<li>回表其实不仅仅只是多查一次，<strong>还会带来随机 I&#x2F;O</strong>。</li>
<li>因为通过 id 去主键索引查询的时候，id 肯定是不连续的（例如 age 为 20 的人很多，age 索引中年龄是有序的，但是 id 无序，且是不连续的），所以去主键索引频繁查询会造成大量随机 I&#x2F;O ，我们都知道顺序 I&#x2F;O 查询快，而随机 I&#x2F;O 慢，所以频繁回表效率很低。</li>
<li>因此，不要因为图方便，在代码里都用 select * ，从而引发不必要的回表操作。</li>
<li><em><strong>覆盖索引</strong></em><ul>
<li>指<strong>查询的列完全包含在某个索引中</strong>，数据库可以直接通过索引返回结果，无需回表（即无需访问数据行）。这种优化可显著减少磁盘 I&#x2F;O，提升查询性能。</li>
<li>假设有一个联合索引<code>INDEX idx_age_city (age, city)</code>,</li>
<li><img src="/project/img/Pasted%20image%2020250312132622.png" srcset="/project/img/loading.gif" lazyload></li>
</ul>
</li>
<li><em><strong>索引下推(Index Condition Pushdown，简称 ICP)</strong></em><ul>
<li>MySQL的大概架构：<ul>
<li><img src="/project/img/Pasted%20image%2020250312132750.png" srcset="/project/img/loading.gif" lazyload></li>
</ul>
</li>
<li><code>索引下推</code>的<strong>下推</strong>其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。</li>
<li><strong>注意：索引下推是应用在<em>联合索引</em>上的。</strong></li>
<li>对<em>InnoDB和MYISAM</em>两个存储引擎都生效</li>
<li>我们来具体看一下，在<em>没有使用ICP</em>的情况下，MySQL的查询：<ul>
<li>存储引擎读取索引记录；</li>
<li>根据索引中的主键值，定位并读取完整的行记录；</li>
<li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li>
</ul>
</li>
<li><em>使用ICP</em>的情况下，查询过程：<ul>
<li>存储引擎读取索引记录（不是完整的行记录）；</li>
<li>判断<code>WHERE</code>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li>
<li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li>
<li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的其余部分。</li>
</ul>
</li>
<li><em><strong>Using index</strong></em>：表示查询可以完全通过索引来获取数据，不需要访问数据表的行（即 “索引覆盖”）。这种情况性能较好，因为只访问了索引，没有读表。</li>
<li><em><strong>Using index condition</strong></em>：表示 MySQL 只使用了索引进行部分过滤，但仍然需要读取表中的数据行。虽然通过索引进行了一定的优化，但相比完全使用索引，性能会略逊一筹。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>推荐操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>高频等值查询</td>
<td>建 B-Tree 索引，优先选择高选择性列。</td>
</tr>
<tr>
<td>范围查询 + 排序</td>
<td>复合索引按等值列在前、范围列在后。</td>
</tr>
<tr>
<td>避免回表</td>
<td>使用覆盖索引。</td>
</tr>
<tr>
<td>长字符串列</td>
<td>使用前缀索引。</td>
</tr>
<tr>
<td>数据频繁更新</td>
<td>减少索引数量，避免在频繁修改的列上建索引。</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>只为高频查询列建索引</strong></p>
<ul>
<li>索引会占用存储空间，且增删改操作需维护索引，<strong>避免过度索引</strong>。</li>
<li>优先为高频查询的 <code>WHERE</code>、<code>JOIN</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 涉及的列建索引。</li>
</ul>
</li>
<li><p><strong>选择合适索引类型</strong></p>
<ul>
<li><strong>B-Tree 索引</strong>：默认类型，支持范围查询（<code>&gt;</code>, <code>&lt;</code>, <code>BETWEEN</code>）、排序和前缀匹配。</li>
<li><strong>哈希索引</strong>：仅支持等值查询（<code>=</code>），适用于内存表（Memory Engine）。</li>
<li><strong>全文索引</strong>：用于文本字段的全文搜索（<code>MATCH ... AGAINST</code>）。</li>
<li><strong>空间索引</strong>：用于地理数据（如 <code>GEOMETRY</code> 类型）。</li>
</ul>
</li>
<li><p><strong>利用最左前缀原则</strong></p>
<ul>
<li>复合索引 <code>(a, b, c)</code> 生效的场景：<ul>
<li><code>WHERE a=1</code></li>
<li><code>WHERE a=1 AND b=2</code></li>
<li><code>WHERE a=1 AND b=2 AND c=3</code></li>
</ul>
</li>
<li><strong>失效的场景</strong>：<ul>
<li><code>WHERE b=2</code>（未使用最左列 <code>a</code>）</li>
<li><code>WHERE a=1 AND c=3</code>（跳过中间列 <code>b</code>）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="MySQL中使用索引一定有效吗"><a href="#MySQL中使用索引一定有效吗" class="headerlink" title="MySQL中使用索引一定有效吗"></a>MySQL中使用索引一定有效吗</h4><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>低选择性索引</strong></td>
<td>索引列的值重复率高（如性别、状态字段），优化器认为全表扫描更快。</td>
</tr>
<tr>
<td><strong>索引列参与运算或函数</strong></td>
<td>例如 <code>WHERE YEAR(create_time) = 2023</code>，索引无法直接使用。</td>
</tr>
<tr>
<td><strong>隐式类型转换</strong></td>
<td>例如字符串列使用数字查询（<code>WHERE id = &#39;100&#39;</code>），导致索引失效。</td>
</tr>
<tr>
<td><strong>未遵循最左前缀原则</strong></td>
<td>复合索引 <code>(a, b, c)</code> 的查询跳过最左列 <code>a</code>，如 <code>WHERE b=2</code>。</td>
</tr>
<tr>
<td><strong>范围查询中断索引连续性</strong></td>
<td>范围查询（如 <code>a &gt; 10</code>）后，复合索引后续列的过滤条件无法直接使用索引。</td>
</tr>
<tr>
<td><strong>使用 <code>!=</code>、<code>NOT IN</code></strong></td>
<td>非等值查询无法有效利用索引。</td>
</tr>
<tr>
<td><strong>小表查询</strong></td>
<td>数据量较少时，优化器可能选择全表扫描而非索引。</td>
</tr>
<tr>
<td><strong>统计信息不准确</strong></td>
<td>索引的基数（Cardinality）统计不准确，导致优化器误判索引效率。</td>
</tr>
<tr>
<td><strong>1. 使用 <code>EXPLAIN</code> 分析执行计划</strong></td>
<td></td>
</tr>
<tr>
<td>通过 <code>EXPLAIN</code> 查看查询是否命中索引及索引使用细节：</td>
<td></td>
</tr>
</tbody></table>
<pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span></code></pre>
<p><strong>关键字段解析</strong>：</p>
<ul>
<li>**<code>type</code>**：访问类型，优先级从高到低：<br>  <code>const &gt; ref &gt; range &gt; index &gt; ALL</code>（<code>ALL</code> 表示全表扫描）。</li>
<li>**<code>key</code>**：实际使用的索引名称。</li>
<li>**<code>rows</code>**：预估扫描的行数，值越小越好。</li>
<li>**<code>Extra</code>**：额外信息，重点关注：<ul>
<li><code>Using index</code>：覆盖索引，无需回表。</li>
<li><code>Using where</code>：存储引擎层无法直接过滤，需 Server 层处理。</li>
<li><code>Using filesort</code>：需要额外排序，可能需优化索引或查询。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.mianshiya.com/question/1780933295463231490">看这篇题解，非常好</a></li>
</ul>
<h4 id="599-MySQL-中的索引数量是否越多越好？为什么？"><a href="#599-MySQL-中的索引数量是否越多越好？为什么？" class="headerlink" title="599. MySQL 中的索引数量是否越多越好？为什么？"></a>599. MySQL 中的索引数量是否越多越好？为什么？</h4><ul>
<li><p><strong>索引并不是越多越好</strong>。因为索引<strong>不论从时间还是空间上都是有一定成本的</strong></p>
</li>
<li><p><strong>1）从时间上</strong></p>
<ul>
<li>每次对表中的数据进行增删改(INSERT、UPDATE 或 DELETE)的时候，索引也必须被更新，这会增加写入操作的开销。例如删除了一个 name 为面试鸭的记录，不仅主键索引上需要修改，如果 name 字段有索引，那么 name 索引也需要修改，所以<strong>索引越多需要修改的地方也就越多，时间开销就大了</strong>，并且 B+ 树可能会有页分裂、合并等操作，时间开销就会更大。</li>
<li>还有一点需要注意：MySQL 有个查询优化器，它需要分析当前的查询，选择最优的计划，这过程就需要考虑选择哪个索引的查询成本低。如果索引过多，那么会导致优化器耗费更多的时间在选择上，甚至可能因为数据的不准确而选择了次优的索引。</li>
</ul>
</li>
<li><p><strong>2）从空间上</strong></p>
<ul>
<li>每建立一个二级索引，都需要新建一个 B+ 树，默认每个数据页都是 16kb，如果数据量很大，索引又很多，占用的空间可不小。</li>
</ul>
</li>
</ul>
<h4 id="612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？"><a href="#612-如何使用-MySQL-的-EXPLAIN-语句进行查询分析？" class="headerlink" title="612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？"></a>612. 如何使用 MySQL 的 EXPLAIN 语句进行查询分析？</h4><ul>
<li><em><strong>回答重点</strong></em><ul>
<li>explain 主要用来 SQL 分析，它主要的属性详解如下：</li>
<li><code>id</code>：查询的执行顺序的标识符，值越大优先级越高。简单查询的 id 通常为 1，复杂查询（如包含子查询或 UNION）的 id 会有多个。</li>
<li><code>select_type</code>（<strong>重要</strong>）：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。</li>
<li><code>table</code>：查询的数据表。</li>
<li><code>type</code>（<strong>重要</strong>）：访问类型，如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）等。一般来说，性能从好到差的顺序是：const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL。</li>
<li><code>possible_keys</code>：可能用到的索引。</li>
<li><code>key</code>（<strong>重要</strong>）：实际用到的索引。</li>
<li><code>key_len</code>：用到索引的长度。</li>
<li><code>ref</code>：显示索引的哪一列被使用。</li>
<li><code>rows</code>（<strong>重要</strong>）：估计要扫描的行数，值越小越好。</li>
<li><code>filtered</code>：显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。</li>
<li><code>Extra</code>（<strong>重要</strong>）：额外信息，如 <code>Using index</code>（表示使用覆盖索引）、<code>Using where</code>（表示使用 WHERE 条件进行过滤）、<code>Using temporary</code>（表示使用临时表）、<code>Using filesort</code>（表示需要额外的排序步骤）。</li>
</ul>
</li>
<li><em><strong>type 详解：</strong></em><ul>
<li>system：表示查询的表只有一行（系统表）。这是一个特殊的情况，不常见。</li>
<li>const：表示查询的表最多只有一行匹配结果。这通常发生在查询条件是<strong>主键</strong>或<strong>唯一索引</strong>，并且是常量比较。</li>
<li>eq_ref：表示对于每个来自前一张表的行，MySQL 仅访问一次这个表。这通常发生在连接查询中使用主键或唯一索引的情况下。</li>
<li>ref：MySQL 使用非唯一索引扫描来查找行。查询条件使用的索引是非唯一的（如普通索引）。</li>
<li>range：表示 MySQL 会扫描表的一部分，而不是全部行。范围扫描通常出现在使用索引的范围查询中（如 <code>BETWEEN</code>、<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>）。</li>
<li>index：表示 MySQL 扫描索引中的所有行，而不是表中的所有行。即使索引列的值覆盖查询，也需要扫描整个索引。</li>
<li>all（性能最差）：表示 MySQL 需要扫描表中的所有行，即全表扫描。通常出现在没有索引的查询条件中。</li>
</ul>
</li>
</ul>
<h4 id="616-MySQL-中如何进行-SQL-调优？"><a href="#616-MySQL-中如何进行-SQL-调优？" class="headerlink" title="616. MySQL 中如何进行 SQL 调优？"></a>616. MySQL 中如何进行 SQL 调优？</h4><ul>
<li><p><em><strong>回答重点</strong></em></p>
<ul>
<li>平时进行 SQL 调优，主要是通过观察慢 SQL，然后利用 explain 分析查询语句的执行计划，识别性能瓶颈，优化查询语句。</li>
</ul>
<ol>
<li><p>合理设计索引，利用联合索引进行覆盖索引的优化，避免回表的发生，减少一次查询和随机 I&#x2F;O</p>
</li>
<li><p>避免 SELECT * ，只查询必要的字段</p>
</li>
<li><p>避免在 SQL 中进行函数计算等操作，使得无法命中索引</p>
</li>
<li><p>避免使用 %LIKE，导致全表扫描</p>
</li>
<li><p>注意联合索引需满足最左匹配原则</p>
</li>
<li><p>不要对无索引字段进行排序操作</p>
</li>
<li><p>连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描</p>
</li>
</ol>
</li>
<li><p>除此之外，还可以<strong>利用缓存</strong>来优化，一些变化少或者访问频繁的数据设置到缓存中，减轻数据库的压力，提升查询的效率。</p>
</li>
<li><p>还可以<strong>通过业务</strong>来优化，例如少展示一些不必要的字段，减少多表查询的情况，将列表查询替换成分页分批查询等等。</p>
</li>
<li><p><em><strong>扩展知识–慢 SQL</strong></em></p>
<ul>
<li><p>这是 MySQL 自带的日志记录，默认关闭，通过 <code>set global slow_query_log = &#39;ON&#39;</code> 即可开启。</p>
</li>
<li><p>通过 <code>show variables like &#39;%slow_query_log%&#39;</code> 即可查询当前慢日志是否开启，以及存储的路径。</p>
</li>
<li><p>通过 <code>set global long_query_time = 3</code> 即可设置慢 SQL 的阈值，3 就是 3 秒，当一个 SQL 执行的时间操作 3 秒，就会被记录到慢日志中。</p>
</li>
</ul>
</li>
</ul>
<h4 id="613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？"><a href="#613-MySQL-中-count-、count-1-和-count-字段名-有什么区别？" class="headerlink" title="613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？"></a>613. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</h4><ul>
<li><em><strong>功能上</strong></em>：<ul>
<li>1）<code>count(*)</code> 会统计表中所有行的数量，包括 <code>null</code> 值（不会忽略任何一行数据）。由于只是计算行数，不需要对具体的列进行处理，因此性能通常较高。</li>
<li>2）<code>count(1)</code> 和 <code>count(*)</code> 几乎没差别，也会统计表中所有行的数量，包括 <code>null</code> 值。</li>
<li>3）<code>count(字段名)</code> 会统计指定字段不为 <code>null</code> 的行数。这种写法会对指定的字段进行计数，只会统计字段值不为 <code>null</code> 的行。</li>
</ul>
</li>
<li><em><strong>效率上</strong></em>：<ul>
<li><code>count(1)</code> 和 <code>count(*)</code> 效率一致</li>
<li><code>count(字段)</code> 的查询就是全表扫描(如果对应的字段没有索引，如果有索引则用索引)，正常情况下它还需要判断字段是否是 null 值，因此理论上会比 <code>count(1)</code> 和 <code>count(*)</code> 慢。</li>
<li>但是如果字段不为 null，例如是主键，那么理论上也差不多，而且本质上它们的统计功能不一样，在需要统计 null 的时候，只能用 <code>count(1)</code> 和 <code>count(*)</code>，不需要统计 null 的时候只能用<code>count(字段)</code>，所以也不用太纠结性能问题。</li>
</ul>
</li>
<li><em><strong>扩展知识</strong></em><ul>
<li><p>在 MyISAM 中，由于只有表锁，因此它把每张表的总数单独记录维护（表锁使得对表的修改是串行，因此能维护总数），所以 <code>count(*)</code> 非常快，因为等于直接返回一个字段。当然，<strong>前提是不需要条件过滤而是直接返回整表数据</strong>。</p>
</li>
<li><p>而 InnoDB 由于支持行锁，所以会有很多并发来修改表的数据，因此无法维护记录总数，但是 InnoDB 对<code>count(*)</code>和<code>count(1)</code>也做了一定的优化。</p>
</li>
<li><p>count 的字段如果是主键，由于主键索引保存的是整行记录，占据的空间和内存都比较大，此时表中如果还有其它二级索引，那么成本会更低，因此 InnoDB 会评估这个成本选择合适的索引扫描。当然，这个前提也是不能有对应的条件过滤等功能。</p>
</li>
</ul>
</li>
<li><img src="/project/img/Pasted_image_20250314103948.png" srcset="/project/img/loading.gif" lazyload></li>
<li><img src="/project/img/Pasted_image_20250314104003.png" srcset="/project/img/loading.gif" lazyload></li>
</ul>
<h4 id="615-MySQL-中-varchar-和-char-有什么区别？"><a href="#615-MySQL-中-varchar-和-char-有什么区别？" class="headerlink" title="615. MySQL 中 varchar 和 char 有什么区别？"></a>615. MySQL 中 varchar 和 char 有什么区别？</h4><ul>
<li><p><img src="/project/img/Pasted_image_20250314105731.png" srcset="/project/img/loading.gif" lazyload></p>
</li>
<li><p>理论上来说 CHAR 会比 VARCHAR 快，因为 VARCHAR 长度不固定，处理需要多一次运算，但是实际上这种运算耗时微乎其微，而固定大小在很多场景下比较浪费空间，除非存储的字符确认是固定大小或者本身就很短，不然业务上推荐使用 VARCHAR。</p>
</li>
<li><p><em><strong>拓展</strong></em></p>
<ul>
<li><p>MySQL 执行 orderby 排序的时候，会利用 sort_buffer。</p>
</li>
<li><p>假设 a、b、c 都为 varchar 类型，当前要执行<code>select a,b,c from t1 where a = &#39;面试鸭&#39; order by b;</code></p>
</li>
<li><p>MySQL 计算 a b c 总长度比较长，sort_buffer 可能放不下，就会使用<strong>双路排序</strong>，即 sort_buffer 里存放需要排序的字段 b 和 id 进行排序，待排完后，再通过 id 回表查询得到a、b、c 字段。这样就多了回表的一步，性能比较差。</p>
</li>
<li><p><img src="/project/img/Pasted_image_20250314110644.png" srcset="/project/img/loading.gif" lazyload></p>
</li>
<li><p>如果 select 字段长度少，那么就可以使用<strong>单路排序</strong>，即将 select 的数据都放入到 sort_buffer 中，排完序后直接返回给客户端。</p>
</li>
<li><p><img src="/project/img/Pasted_image_20250314110659.png" srcset="/project/img/loading.gif" lazyload></p>
</li>
<li><p>这里计算 a、b、c 长度依据的就是 varchar(n) 中的 n，所以如果 n 设置很大，虽然占用空间是动态的，但是会隐性影响排序的性能。</p>
</li>
</ul>
</li>
<li><p><em><strong>varchar支持的最大长度</strong></em></p>
<blockquote>
<p>mysql column length is within the maximum length of 65,535 bytes</p>
</blockquote>
</li>
<li><p>因为最大行长度有限，所以要计算 VARCHAR 支持最大长度，仅当一行只有一个 VARCHAR 字段时，这个 VARCHAR 字段能达到最大长度（没有别的字段来占用空间）。</p>
</li>
<li><p>最大行长度是 65535 字节，如果值允许为 null，则需要额外 1bit 标记是否为 null（mysql 最对于 null 值是额外用一个 null值列表存储的。当前只有一个 VARCHAR 字段，需要用 1 个 bit 标记它的 null 值组成 null 值列表，mysql 要求 null 值列表最少需要一个字节，所以需要占用 1 个字节），又因为 VARCHAR 列的长度是可变的，需要 1 到 2 个字节（字符长度超过 255，则使用两个字节）用于存储字符串的长度信息。</p>
</li>
<li><p>所以支持的最大长度是 <code>65535 - 2 = 65533</code>，如果允许为 null 则是 <code>65532</code>。</p>
</li>
<li><p>以上是字节数，实际的字符又取决于使用的字符集。</p>
<ul>
<li>UTF-8 字符集：每个字符最大占用 3 字节（但也可以是 1 字节、2 字节或 3 字节，具体取决于字符的实际编码）。因此，最大字符数会受限于字符集的编码方式。如果使用 UTF-8，最大字符数大约是 21844 字符（65533 ÷ 3）。</li>
<li>UTF-16 字符集：每个字符通常占用 2 字节。最大字符数大约是 32766 字符（65533 ÷ 2）。</li>
<li>Latin1 字符集：每个字符占用 1 字节，所以最大字符数为 65533 字符。</li>
</ul>
</li>
<li><p>在定义 <code>VARCHAR(n)</code> 时，n 代表的是字符的个数，而不是字节数。</p>
</li>
</ul>
<h4 id="600-请详细描述-MySQL-的-B-树中查询数据的全过程"><a href="#600-请详细描述-MySQL-的-B-树中查询数据的全过程" class="headerlink" title="600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程"></a>600. 请详细描述 MySQL 的 B+ 树中查询数据的全过程</h4><p>1）数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点<br>2）叶子节点存储实际的数据行记录，但是一页有 16kb 大小，存储的数据行不止一条<br>3）叶子节点中数据行以组的形式划分，利用<strong>页目录</strong>结构，通过二分查找可以定位到对应的组<br>4）定位组后，利用链表遍历就可以找到对应的数据行</p>
<ul>
<li><em><strong>详细流程</strong></em><ul>
<li><p>数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点。</p>
</li>
<li><p><img src="/project/img/Pasted_image_20250314112930.png" srcset="/project/img/loading.gif" lazyload></p>
</li>
<li><p>定位到叶子节点后，因为一片叶子默认有 16k 大小，所以理论上可以存多条记录。叶子节点的实际构造如下图所示：</p>
</li>
<li><p><img src="/project/img/Pasted_image_20250314112940.png" srcset="/project/img/loading.gif" lazyload></p>
</li>
<li><p>从上图可以知晓，叶子节点有<strong>页目录</strong>结构，它其实就是一个索引，通过它可以快速找到记录。</p>
</li>
<li><p>页目录分为了多个槽，每个槽都指向对应一个分组内的最大记录，每个分组内都会包含若干条记录。</p>
</li>
<li><p>通过<strong>二分查询</strong>，利用槽就能直接定位到记录所在的组，从而就能获取到对应的记录。</p>
</li>
<li><p>举个例子，现在有 5 个槽，如果想查找主键为 3 的记录，此时的流程是：</p>
</li>
<li><p>1）通过二分得到槽的中间位置，<code>low = 0</code>，<code>high = 4</code>，<code>（0+4)/2 = 2</code>; </p>
</li>
<li><p>2）通过槽定位到第二个分组中的主键为 4 的记录，4 大于 3，<code>low = 0</code> 不变，<code>high = 2</code>; </p>
</li>
<li><p>3）继续二分 <code>(0+2)/2 = 1</code>; 槽 1 中主键 2 小于 3，<code>low = 1</code>，<code>high = 2</code>; </p>
</li>
<li><p>4）此时 <code>high - low = 1</code>，可以确定值在 high 即槽 2 中，但是槽 2 只能定位到主键为 4 的记录，又因为槽之间是挨着的，所以可以得到槽 1 的位置，从槽 1 入手拿到 主键 2 的记录，然后因为记录是通过单向链表串起来的，往下遍历即可定位到主键 3 的记录。</p>
</li>
<li><p>以上就是利用二分查询的定位流程。通过槽可找到对应记录所在的组，或能直接定位到记录，或还需通过链表遍历找到对应的数据。</p>
</li>
<li><p>实际上，每个分组的记录数是有规定的，图中做了省略只画了两条，InnoDB 规定：</p>
<ul>
<li>第一个分组只有一条记录</li>
<li>中间的分组 4-8 条记录</li>
<li>最后一个分组 1-8 条记录</li>
</ul>
</li>
<li><p>因此不必担心遍历很长的链表导致性能问题。</p>
</li>
</ul>
</li>
</ul>
<h4 id="602-MySQL-是如何实现事务的？"><a href="#602-MySQL-是如何实现事务的？" class="headerlink" title="602. MySQL 是如何实现事务的？"></a>602. MySQL 是如何实现事务的？</h4><h4 id="604-MySQL-中的-MVCC-是什么？"><a href="#604-MySQL-中的-MVCC-是什么？" class="headerlink" title="604. MySQL 中的 MVCC 是什么？"></a>604. MySQL 中的 MVCC 是什么？</h4><h4 id="106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？"><a href="#106-MySQL-中的日志类型有哪些？binlog、redo-log-和-undo-log-的作用和区别是什么？" class="headerlink" title="106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？"></a>106. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？</h4>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/project/categories/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E9%A2%98/" class="category-chain-item">面试八股题</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/project/tags/MySQL/" class="print-no-link">##MySQL</a>
      
        <a href="/project/tags/%E5%85%AB%E8%82%A1/" class="print-no-link">##八股</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>1.MySQL</div>
      <div>https://vvx94.github.io/project/posts/aaba9777.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>十众</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/project/posts/2980492.html" title="conda">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">conda</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/project/js/events.js" ></script>
<script  src="/project/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/project/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/project/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/project/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
